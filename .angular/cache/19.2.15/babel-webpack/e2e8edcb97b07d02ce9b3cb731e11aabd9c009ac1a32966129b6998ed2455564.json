{"ast":null,"code":"var Rive = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return function (moduleArg = {}) {\n    var m = moduleArg,\n      aa,\n      ba;\n    m.ready = new Promise((b, a) => {\n      aa = b;\n      ba = a;\n    });\n    function ca() {\n      function b(h) {\n        const g = d;\n        c = a = 0;\n        d = new Map();\n        g.forEach(l => {\n          try {\n            l(h);\n          } catch (k) {\n            console.error(k);\n          }\n        });\n        this.Sa();\n        e && e.pb();\n      }\n      let a = 0,\n        c = 0,\n        d = new Map(),\n        e = null,\n        f = null;\n      this.requestAnimationFrame = function (h) {\n        a || (a = requestAnimationFrame(b.bind(this)));\n        const g = ++c;\n        d.set(g, h);\n        return g;\n      };\n      this.cancelAnimationFrame = function (h) {\n        d.delete(h);\n        a && 0 == d.size && (cancelAnimationFrame(a), a = 0);\n      };\n      this.nb = function (h) {\n        f && (document.body.remove(f), f = null);\n        h || (f = document.createElement(\"div\"), f.style.backgroundColor = \"black\", f.style.position = \"fixed\", f.style.right = 0, f.style.top = 0, f.style.color = \"white\", f.style.padding = \"4px\", f.innerHTML = \"RIVE FPS\", h = function (g) {\n          f.innerHTML = \"RIVE FPS \" + g.toFixed(1);\n        }, document.body.appendChild(f));\n        e = new function () {\n          let g = 0,\n            l = 0;\n          this.pb = function () {\n            var k = performance.now();\n            l ? (++g, k -= l, 1E3 < k && (h(1E3 * g / k), g = l = 0)) : (l = k, g = 0);\n          };\n        }();\n      };\n      this.kb = function () {\n        f && (document.body.remove(f), f = null);\n        e = null;\n      };\n      this.Sa = function () {};\n    }\n    function da(b) {\n      console.assert(!0);\n      const a = new Map();\n      let c = -Infinity;\n      this.push = function (d) {\n        d = d + ((1 << b) - 1) >> b;\n        a.has(d) && clearTimeout(a.get(d));\n        a.set(d, setTimeout(function () {\n          a.delete(d);\n          0 == a.length ? c = -Infinity : d == c && (c = Math.max(...a.keys()), console.assert(c < d));\n        }, 1E3));\n        c = Math.max(d, c);\n        return c << b;\n      };\n    }\n    const fa = \"createConicGradient createImageData createLinearGradient createPattern createRadialGradient getContextAttributes getImageData getLineDash getTransform isContextLost isPointInPath isPointInStroke measureText\".split(\" \"),\n      ha = new function () {\n        function b() {\n          if (!a) {\n            var t = document.createElement(\"canvas\"),\n              v = {\n                alpha: 1,\n                depth: 0,\n                stencil: 0,\n                antialias: 0,\n                premultipliedAlpha: 1,\n                preserveDrawingBuffer: 0,\n                preferLowPowerToHighPerformance: 0,\n                failIfMajorPerformanceCaveat: 0,\n                enableExtensionsByDefault: 1,\n                explicitSwapControl: 1,\n                renderViaOffscreenBackBuffer: 1\n              };\n            let q = t.getContext(\"webgl2\", v);\n            if (q) c = 2;else if (q = t.getContext(\"webgl\", v)) c = 1;else return console.log(\"No WebGL support. Image mesh will not be drawn.\"), !1;\n            d = Math.min(q.getParameter(q.MAX_RENDERBUFFER_SIZE), q.getParameter(q.MAX_TEXTURE_SIZE));\n            function G(I, w, z) {\n              w = q.createShader(w);\n              q.shaderSource(w, z);\n              q.compileShader(w);\n              z = q.getShaderInfoLog(w);\n              if (0 < z.length) throw z;\n              q.attachShader(I, w);\n            }\n            t = q.createProgram();\n            G(t, q.VERTEX_SHADER, \"attribute vec2 vertex;\\n                attribute vec2 uv;\\n                uniform vec4 mat;\\n                uniform vec2 translate;\\n                varying vec2 st;\\n                void main() {\\n                    st = uv;\\n                    gl_Position = vec4(mat2(mat) * vertex + translate, 0, 1);\\n                }\");\n            G(t, q.FRAGMENT_SHADER, \"precision highp float;\\n                uniform sampler2D image;\\n                varying vec2 st;\\n                void main() {\\n                    gl_FragColor = texture2D(image, st);\\n                }\");\n            q.bindAttribLocation(t, 0, \"vertex\");\n            q.bindAttribLocation(t, 1, \"uv\");\n            q.linkProgram(t);\n            v = q.getProgramInfoLog(t);\n            if (0 < v.trim().length) throw v;\n            e = q.getUniformLocation(t, \"mat\");\n            f = q.getUniformLocation(t, \"translate\");\n            q.useProgram(t);\n            q.bindBuffer(q.ARRAY_BUFFER, q.createBuffer());\n            q.enableVertexAttribArray(0);\n            q.enableVertexAttribArray(1);\n            q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, q.createBuffer());\n            q.uniform1i(q.getUniformLocation(t, \"image\"), 0);\n            q.pixelStorei(q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);\n            a = q;\n          }\n          return !0;\n        }\n        let a = null,\n          c = 0,\n          d = 0,\n          e = null,\n          f = null,\n          h = 0,\n          g = 0;\n        this.yb = function () {\n          b();\n          return d;\n        };\n        this.ib = function (t) {\n          if (!b()) return null;\n          const v = a.createTexture();\n          a.bindTexture(a.TEXTURE_2D, v);\n          a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, t);\n          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);\n          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);\n          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR);\n          2 == c ? (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_LINEAR), a.generateMipmap(a.TEXTURE_2D)) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);\n          return v;\n        };\n        const l = new da(8),\n          k = new da(8),\n          p = new da(10),\n          r = new da(10);\n        this.mb = function (t, v, q, G, I) {\n          if (b()) {\n            var w = l.push(t),\n              z = k.push(v);\n            if (a.canvas.width != w || a.canvas.height != z) a.canvas.width = w, a.canvas.height = z;\n            a.viewport(0, z - v, t, v);\n            a.disable(a.SCISSOR_TEST);\n            a.clearColor(0, 0, 0, 0);\n            a.clear(a.COLOR_BUFFER_BIT);\n            a.enable(a.SCISSOR_TEST);\n            q.sort((B, ea) => ea.Wa - B.Wa);\n            w = p.push(G);\n            h != w && (a.bufferData(a.ARRAY_BUFFER, 8 * w, a.DYNAMIC_DRAW), h = w);\n            w = 0;\n            for (var J of q) a.bufferSubData(a.ARRAY_BUFFER, w, J.Fa), w += 4 * J.Fa.length;\n            console.assert(w == 4 * G);\n            for (var P of q) a.bufferSubData(a.ARRAY_BUFFER, w, P.Za), w += 4 * P.Za.length;\n            console.assert(w == 8 * G);\n            w = r.push(I);\n            g != w && (a.bufferData(a.ELEMENT_ARRAY_BUFFER, 2 * w, a.DYNAMIC_DRAW), g = w);\n            J = 0;\n            for (var Y of q) a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, J, Y.indices), J += 2 * Y.indices.length;\n            console.assert(J == 2 * I);\n            Y = 0;\n            P = !0;\n            w = J = 0;\n            for (const B of q) {\n              B.image.Ba != Y && (a.bindTexture(a.TEXTURE_2D, B.image.fb || null), Y = B.image.Ba);\n              B.Bb ? (a.scissor(B.Ka, z - B.La - B.Ra, B.Ib, B.Ra), P = !0) : P && (a.scissor(0, z - v, t, v), P = !1);\n              q = 2 / t;\n              const ea = -2 / v;\n              a.uniform4f(e, B.qa[0] * q * B.xa, B.qa[1] * ea * B.ya, B.qa[2] * q * B.xa, B.qa[3] * ea * B.ya);\n              a.uniform2f(f, B.qa[4] * q * B.xa + q * (B.Ka - B.zb * B.xa) - 1, B.qa[5] * ea * B.ya + ea * (B.La - B.Ab * B.ya) + 1);\n              a.vertexAttribPointer(0, 2, a.FLOAT, !1, 0, w);\n              a.vertexAttribPointer(1, 2, a.FLOAT, !1, 0, w + 4 * G);\n              a.drawElements(a.TRIANGLES, B.indices.length, a.UNSIGNED_SHORT, J);\n              w += 4 * B.Fa.length;\n              J += 2 * B.indices.length;\n            }\n            console.assert(w == 4 * G);\n            console.assert(J == 2 * I);\n          }\n        };\n        this.canvas = function () {\n          return b() && a.canvas;\n        };\n      }();\n    m.onRuntimeInitialized = function () {\n      function b(n) {\n        switch (n) {\n          case k.srcOver:\n            return \"source-over\";\n          case k.screen:\n            return \"screen\";\n          case k.overlay:\n            return \"overlay\";\n          case k.darken:\n            return \"darken\";\n          case k.lighten:\n            return \"lighten\";\n          case k.colorDodge:\n            return \"color-dodge\";\n          case k.colorBurn:\n            return \"color-burn\";\n          case k.hardLight:\n            return \"hard-light\";\n          case k.softLight:\n            return \"soft-light\";\n          case k.difference:\n            return \"difference\";\n          case k.exclusion:\n            return \"exclusion\";\n          case k.multiply:\n            return \"multiply\";\n          case k.hue:\n            return \"hue\";\n          case k.saturation:\n            return \"saturation\";\n          case k.color:\n            return \"color\";\n          case k.luminosity:\n            return \"luminosity\";\n        }\n      }\n      function a(n) {\n        return \"rgba(\" + ((16711680 & n) >>> 16) + \",\" + ((65280 & n) >>> 8) + \",\" + ((255 & n) >>> 0) + \",\" + ((4278190080 & n) >>> 24) / 255 + \")\";\n      }\n      function c() {\n        0 < J.length && (ha.mb(z.drawWidth(), z.drawHeight(), J, P, Y), J = [], Y = P = 0, z.reset(512, 512));\n        for (const n of w) {\n          for (const u of n.fa) u();\n          n.fa = [];\n        }\n        w.clear();\n      }\n      var d = m.RenderPaintStyle;\n      const e = m.RenderPath,\n        f = m.RenderPaint,\n        h = m.Renderer,\n        g = m.StrokeCap,\n        l = m.StrokeJoin,\n        k = m.BlendMode,\n        p = d.fill,\n        r = d.stroke,\n        t = m.FillRule.evenOdd;\n      let v = 1;\n      var q = m.RenderImage.extend(\"CanvasRenderImage\", {\n          __construct: function () {\n            this.__parent.__construct.call(this);\n            this.Ba = v;\n            v = v + 1 & 2147483647 || 1;\n          },\n          decode: function (n) {\n            let u = Xa;\n            u.total++;\n            var C = this,\n              A = new Image();\n            A.src = URL.createObjectURL(new Blob([n], {\n              type: \"image/png\"\n            }));\n            A.onload = function () {\n              C.cb = A;\n              C.fb = ha.ib(A);\n              C.size(A.width, A.height);\n              u.loaded++;\n              if (u.loaded === u.total) {\n                const y = u.ready;\n                y && (y(), u.ready = null);\n              }\n            };\n          }\n        }),\n        G = e.extend(\"CanvasRenderPath\", {\n          __construct: function () {\n            this.__parent.__construct.call(this);\n            this.ka = new Path2D();\n          },\n          rewind: function () {\n            this.ka = new Path2D();\n          },\n          addPath: function (n, u, C, A, y, F, D) {\n            var E = this.ka,\n              R = E.addPath;\n            n = n.ka;\n            const K = new DOMMatrix();\n            K.a = u;\n            K.b = C;\n            K.c = A;\n            K.d = y;\n            K.e = F;\n            K.f = D;\n            R.call(E, n, K);\n          },\n          fillRule: function (n) {\n            this.Ia = n;\n          },\n          moveTo: function (n, u) {\n            this.ka.moveTo(n, u);\n          },\n          lineTo: function (n, u) {\n            this.ka.lineTo(n, u);\n          },\n          cubicTo: function (n, u, C, A, y, F) {\n            this.ka.bezierCurveTo(n, u, C, A, y, F);\n          },\n          close: function () {\n            this.ka.closePath();\n          }\n        }),\n        I = f.extend(\"CanvasRenderPaint\", {\n          color: function (n) {\n            this.Ja = a(n);\n          },\n          thickness: function (n) {\n            this.gb = n;\n          },\n          join: function (n) {\n            switch (n) {\n              case l.miter:\n                this.Aa = \"miter\";\n                break;\n              case l.round:\n                this.Aa = \"round\";\n                break;\n              case l.bevel:\n                this.Aa = \"bevel\";\n            }\n          },\n          cap: function (n) {\n            switch (n) {\n              case g.butt:\n                this.za = \"butt\";\n                break;\n              case g.round:\n                this.za = \"round\";\n                break;\n              case g.square:\n                this.za = \"square\";\n            }\n          },\n          style: function (n) {\n            this.eb = n;\n          },\n          blendMode: function (n) {\n            this.bb = b(n);\n          },\n          clearGradient: function () {\n            this.sa = null;\n          },\n          linearGradient: function (n, u, C, A) {\n            this.sa = {\n              Xa: n,\n              Ya: u,\n              Na: C,\n              Oa: A,\n              Ea: []\n            };\n          },\n          radialGradient: function (n, u, C, A) {\n            this.sa = {\n              Xa: n,\n              Ya: u,\n              Na: C,\n              Oa: A,\n              Ea: [],\n              wb: !0\n            };\n          },\n          addStop: function (n, u) {\n            this.sa.Ea.push({\n              color: n,\n              stop: u\n            });\n          },\n          completeGradient: function () {},\n          draw: function (n, u, C) {\n            let A = this.eb;\n            var y = this.Ja,\n              F = this.sa;\n            n.globalCompositeOperation = this.bb;\n            if (null != F) {\n              y = F.Xa;\n              var D = F.Ya;\n              const R = F.Na;\n              var E = F.Oa;\n              const K = F.Ea;\n              F.wb ? (F = R - y, E -= D, y = n.createRadialGradient(y, D, 0, y, D, Math.sqrt(F * F + E * E))) : y = n.createLinearGradient(y, D, R, E);\n              for (let U = 0, M = K.length; U < M; U++) D = K[U], y.addColorStop(D.stop, a(D.color));\n              this.Ja = y;\n              this.sa = null;\n            }\n            switch (A) {\n              case r:\n                n.strokeStyle = y;\n                n.lineWidth = this.gb;\n                n.lineCap = this.za;\n                n.lineJoin = this.Aa;\n                n.stroke(u);\n                break;\n              case p:\n                n.fillStyle = y, n.fill(u, C);\n            }\n          }\n        });\n      const w = new Set();\n      let z = null,\n        J = [],\n        P = 0,\n        Y = 0;\n      var B = m.CanvasRenderer = h.extend(\"Renderer\", {\n        __construct: function (n) {\n          this.__parent.__construct.call(this);\n          this.ja = [1, 0, 0, 1, 0, 0];\n          this.da = n.getContext(\"2d\");\n          this.Ha = n;\n          this.fa = [];\n        },\n        save: function () {\n          this.ja.push(...this.ja.slice(this.ja.length - 6));\n          this.fa.push(this.da.save.bind(this.da));\n        },\n        restore: function () {\n          const n = this.ja.length - 6;\n          if (6 > n) throw \"restore() called without matching save().\";\n          this.ja.splice(n);\n          this.fa.push(this.da.restore.bind(this.da));\n        },\n        transform: function (n, u, C, A, y, F) {\n          const D = this.ja,\n            E = D.length - 6;\n          D.splice(E, 6, D[E] * n + D[E + 2] * u, D[E + 1] * n + D[E + 3] * u, D[E] * C + D[E + 2] * A, D[E + 1] * C + D[E + 3] * A, D[E] * y + D[E + 2] * F + D[E + 4], D[E + 1] * y + D[E + 3] * F + D[E + 5]);\n          this.fa.push(this.da.transform.bind(this.da, n, u, C, A, y, F));\n        },\n        rotate: function (n) {\n          const u = Math.sin(n);\n          n = Math.cos(n);\n          this.transform(n, u, -u, n, 0, 0);\n        },\n        _drawPath: function (n, u) {\n          this.fa.push(u.draw.bind(u, this.da, n.ka, n.Ia === t ? \"evenodd\" : \"nonzero\"));\n        },\n        _drawRiveImage: function (n, u, C) {\n          var A = n.cb;\n          if (A) {\n            var y = this.da,\n              F = b(u);\n            this.fa.push(function () {\n              y.globalCompositeOperation = F;\n              y.globalAlpha = C;\n              y.drawImage(A, 0, 0);\n              y.globalAlpha = 1;\n            });\n          }\n        },\n        _getMatrix: function (n) {\n          const u = this.ja,\n            C = u.length - 6;\n          for (let A = 0; 6 > A; ++A) n[A] = u[C + A];\n        },\n        _drawImageMesh: function (n, u, C, A, y, F, D, E, R, K) {\n          var U = this.da.canvas.width,\n            M = this.da.canvas.height;\n          const pb = R - D,\n            qb = K - E;\n          D = Math.max(D, 0);\n          E = Math.max(E, 0);\n          R = Math.min(R, U);\n          K = Math.min(K, M);\n          const ua = R - D,\n            va = K - E;\n          console.assert(ua <= Math.min(pb, U));\n          console.assert(va <= Math.min(qb, M));\n          if (!(0 >= ua || 0 >= va)) {\n            R = ua < pb || va < qb;\n            U = K = 1;\n            var ia = Math.ceil(ua * K),\n              ja = Math.ceil(va * U);\n            M = ha.yb();\n            ia > M && (K *= M / ia, ia = M);\n            ja > M && (U *= M / ja, ja = M);\n            z || (z = new m.DynamicRectanizer(M), z.reset(512, 512));\n            M = z.addRect(ia, ja);\n            0 > M && (c(), w.add(this), M = z.addRect(ia, ja), console.assert(0 <= M));\n            var rb = M & 65535,\n              sb = M >> 16;\n            J.push({\n              qa: this.ja.slice(this.ja.length - 6),\n              image: n,\n              Ka: rb,\n              La: sb,\n              zb: D,\n              Ab: E,\n              Ib: ia,\n              Ra: ja,\n              xa: K,\n              ya: U,\n              Fa: new Float32Array(A),\n              Za: new Float32Array(y),\n              indices: new Uint16Array(F),\n              Bb: R,\n              Wa: n.Ba << 1 | (R ? 1 : 0)\n            });\n            P += A.length;\n            Y += F.length;\n            var na = this.da,\n              dc = b(u);\n            this.fa.push(function () {\n              na.save();\n              na.resetTransform();\n              na.globalCompositeOperation = dc;\n              na.globalAlpha = C;\n              na.drawImage(ha.canvas(), rb, sb, ia, ja, D, E, ua, va);\n              na.restore();\n            });\n          }\n        },\n        _clipPath: function (n) {\n          this.fa.push(this.da.clip.bind(this.da, n.ka, n.Ia === t ? \"evenodd\" : \"nonzero\"));\n        },\n        clear: function () {\n          w.add(this);\n          this.fa.push(this.da.clearRect.bind(this.da, 0, 0, this.Ha.width, this.Ha.height));\n        },\n        flush: function () {},\n        translate: function (n, u) {\n          this.transform(1, 0, 0, 1, n, u);\n        }\n      });\n      m.makeRenderer = function (n) {\n        const u = new B(n),\n          C = u.da;\n        return new Proxy(u, {\n          get(A, y) {\n            if (\"function\" === typeof A[y]) return function (...F) {\n              return A[y].apply(A, F);\n            };\n            if (\"function\" === typeof C[y]) {\n              if (-1 < fa.indexOf(y)) throw Error(\"RiveException: Method call to '\" + y + \"()' is not allowed, as the renderer cannot immediately pass through the return                 values of any canvas 2d context methods.\");\n              return function (...F) {\n                u.fa.push(C[y].bind(C, ...F));\n              };\n            }\n            return A[y];\n          },\n          set(A, y, F) {\n            if (y in C) return C[y] = F, !0;\n          }\n        });\n      };\n      m.renderFactory = {\n        makeRenderPaint: function () {\n          return new I();\n        },\n        makeRenderPath: function () {\n          return new G();\n        },\n        makeRenderImage: function () {\n          return new q();\n        }\n      };\n      let ea = m.load,\n        Xa = null;\n      m.load = function (n) {\n        return new Promise(function (u) {\n          let C = null;\n          Xa = {\n            total: 0,\n            loaded: 0,\n            ready: function () {\n              u(C);\n            }\n          };\n          C = ea(n);\n          0 == Xa.total && u(C);\n        });\n      };\n      d = new ca();\n      m.requestAnimationFrame = d.requestAnimationFrame.bind(d);\n      m.cancelAnimationFrame = d.cancelAnimationFrame.bind(d);\n      m.enableFPSCounter = d.nb.bind(d);\n      m.disableFPSCounter = d.kb;\n      d.Sa = c;\n      m.cleanup = function () {\n        z && z.delete();\n      };\n    };\n    var ka = Object.assign({}, m),\n      la = \"./this.program\",\n      ma = \"object\" == typeof window,\n      oa = \"function\" == typeof importScripts,\n      x = \"\",\n      pa,\n      qa;\n    if (ma || oa) oa ? x = self.location.href : \"undefined\" != typeof document && document.currentScript && (x = document.currentScript.src), _scriptDir && (x = _scriptDir), 0 !== x.indexOf(\"blob:\") ? x = x.substr(0, x.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : x = \"\", oa && (qa = b => {\n      var a = new XMLHttpRequest();\n      a.open(\"GET\", b, !1);\n      a.responseType = \"arraybuffer\";\n      a.send(null);\n      return new Uint8Array(a.response);\n    }), pa = (b, a, c) => {\n      var d = new XMLHttpRequest();\n      d.open(\"GET\", b, !0);\n      d.responseType = \"arraybuffer\";\n      d.onload = () => {\n        200 == d.status || 0 == d.status && d.response ? a(d.response) : c();\n      };\n      d.onerror = c;\n      d.send(null);\n    };\n    var ra = m.print || console.log.bind(console),\n      sa = m.printErr || console.error.bind(console);\n    Object.assign(m, ka);\n    ka = null;\n    m.thisProgram && (la = m.thisProgram);\n    var ta;\n    m.wasmBinary && (ta = m.wasmBinary);\n    var noExitRuntime = m.noExitRuntime || !0;\n    \"object\" != typeof WebAssembly && wa(\"no native wasm support detected\");\n    var xa,\n      H,\n      ya = !1,\n      za,\n      L,\n      Aa,\n      Ba,\n      Ca,\n      N,\n      Da,\n      Ea;\n    function Fa() {\n      var b = xa.buffer;\n      m.HEAP8 = za = new Int8Array(b);\n      m.HEAP16 = Aa = new Int16Array(b);\n      m.HEAP32 = Ca = new Int32Array(b);\n      m.HEAPU8 = L = new Uint8Array(b);\n      m.HEAPU16 = Ba = new Uint16Array(b);\n      m.HEAPU32 = N = new Uint32Array(b);\n      m.HEAPF32 = Da = new Float32Array(b);\n      m.HEAPF64 = Ea = new Float64Array(b);\n    }\n    var Ga,\n      Ha = [],\n      Ia = [],\n      Ja = [];\n    function Ka() {\n      var b = m.preRun.shift();\n      Ha.unshift(b);\n    }\n    var La = 0,\n      Ma = null,\n      Na = null;\n    function wa(b) {\n      if (m.onAbort) m.onAbort(b);\n      b = \"Aborted(\" + b + \")\";\n      sa(b);\n      ya = !0;\n      b = new WebAssembly.RuntimeError(b + \". Build with -sASSERTIONS for more info.\");\n      ba(b);\n      throw b;\n    }\n    function Oa(b) {\n      return b.startsWith(\"data:application/octet-stream;base64,\");\n    }\n    var Pa;\n    Pa = \"canvas_advanced.wasm\";\n    if (!Oa(Pa)) {\n      var Qa = Pa;\n      Pa = m.locateFile ? m.locateFile(Qa, x) : x + Qa;\n    }\n    function Ra(b) {\n      if (b == Pa && ta) return new Uint8Array(ta);\n      if (qa) return qa(b);\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n    function Sa(b) {\n      if (!ta && (ma || oa)) {\n        if (\"function\" == typeof fetch && !b.startsWith(\"file://\")) return fetch(b, {\n          credentials: \"same-origin\"\n        }).then(a => {\n          if (!a.ok) throw \"failed to load wasm binary file at '\" + b + \"'\";\n          return a.arrayBuffer();\n        }).catch(() => Ra(b));\n        if (pa) return new Promise((a, c) => {\n          pa(b, d => a(new Uint8Array(d)), c);\n        });\n      }\n      return Promise.resolve().then(() => Ra(b));\n    }\n    function Ta(b, a, c) {\n      return Sa(b).then(d => WebAssembly.instantiate(d, a)).then(d => d).then(c, d => {\n        sa(\"failed to asynchronously prepare wasm: \" + d);\n        wa(d);\n      });\n    }\n    function Ua(b, a) {\n      var c = Pa;\n      return ta || \"function\" != typeof WebAssembly.instantiateStreaming || Oa(c) || c.startsWith(\"file://\") || \"function\" != typeof fetch ? Ta(c, b, a) : fetch(c, {\n        credentials: \"same-origin\"\n      }).then(d => WebAssembly.instantiateStreaming(d, b).then(a, function (e) {\n        sa(\"wasm streaming compile failed: \" + e);\n        sa(\"falling back to ArrayBuffer instantiation\");\n        return Ta(c, b, a);\n      }));\n    }\n    var Va = b => {\n      for (; 0 < b.length;) b.shift()(m);\n    };\n    function Wa(b) {\n      if (void 0 === b) return \"_unknown\";\n      b = b.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var a = b.charCodeAt(0);\n      return 48 <= a && 57 >= a ? `_${b}` : b;\n    }\n    function Ya(b, a) {\n      b = Wa(b);\n      return {\n        [b]: function () {\n          return a.apply(this, arguments);\n        }\n      }[b];\n    }\n    function Za() {\n      this.la = [void 0];\n      this.Qa = [];\n    }\n    var O = new Za(),\n      $a = void 0;\n    function Q(b) {\n      throw new $a(b);\n    }\n    var S = b => {\n        b || Q(\"Cannot use deleted val. handle = \" + b);\n        return O.get(b).value;\n      },\n      T = b => {\n        switch (b) {\n          case void 0:\n            return 1;\n          case null:\n            return 2;\n          case !0:\n            return 3;\n          case !1:\n            return 4;\n          default:\n            return O.ab({\n              Va: 1,\n              value: b\n            });\n        }\n      };\n    function ab(b) {\n      var a = Error,\n        c = Ya(b, function (d) {\n          this.name = b;\n          this.message = d;\n          d = Error(d).stack;\n          void 0 !== d && (this.stack = this.toString() + \"\\n\" + d.replace(/^Error(:[^\\n]*)?\\n/, \"\"));\n        });\n      c.prototype = Object.create(a.prototype);\n      c.prototype.constructor = c;\n      c.prototype.toString = function () {\n        return void 0 === this.message ? this.name : `${this.name}: ${this.message}`;\n      };\n      return c;\n    }\n    var bb = void 0,\n      cb = void 0;\n    function V(b) {\n      for (var a = \"\"; L[b];) a += cb[L[b++]];\n      return a;\n    }\n    var db = [];\n    function eb() {\n      for (; db.length;) {\n        var b = db.pop();\n        b.Y.pa = !1;\n        b[\"delete\"]();\n      }\n    }\n    var fb = void 0,\n      gb = {};\n    function hb(b, a) {\n      for (void 0 === a && Q(\"ptr should not be undefined\"); b.ba;) a = b.ta(a), b = b.ba;\n      return a;\n    }\n    var ib = {};\n    function jb(b) {\n      b = kb(b);\n      var a = V(b);\n      lb(b);\n      return a;\n    }\n    function mb(b, a) {\n      var c = ib[b];\n      void 0 === c && Q(a + \" has unknown type \" + jb(b));\n      return c;\n    }\n    function nb() {}\n    var ob = !1;\n    function tb(b) {\n      --b.count.value;\n      0 === b.count.value && (b.ea ? b.ha.ma(b.ea) : b.aa.Z.ma(b.$));\n    }\n    function ub(b, a, c) {\n      if (a === c) return b;\n      if (void 0 === c.ba) return null;\n      b = ub(b, a, c.ba);\n      return null === b ? null : c.lb(b);\n    }\n    var vb = {};\n    function wb(b, a) {\n      a = hb(b, a);\n      return gb[a];\n    }\n    var xb = void 0;\n    function yb(b) {\n      throw new xb(b);\n    }\n    function zb(b, a) {\n      a.aa && a.$ || yb(\"makeClassHandle requires ptr and ptrType\");\n      !!a.ha !== !!a.ea && yb(\"Both smartPtrType and smartPtr must be specified\");\n      a.count = {\n        value: 1\n      };\n      return Ab(Object.create(b, {\n        Y: {\n          value: a\n        }\n      }));\n    }\n    function Ab(b) {\n      if (\"undefined\" === typeof FinalizationRegistry) return Ab = a => a, b;\n      ob = new FinalizationRegistry(a => {\n        tb(a.Y);\n      });\n      Ab = a => {\n        var c = a.Y;\n        c.ea && ob.register(a, {\n          Y: c\n        }, a);\n        return a;\n      };\n      nb = a => {\n        ob.unregister(a);\n      };\n      return Ab(b);\n    }\n    var Bb = {};\n    function Cb(b) {\n      for (; b.length;) {\n        var a = b.pop();\n        b.pop()(a);\n      }\n    }\n    function Db(b) {\n      return this.fromWireType(Ca[b >> 2]);\n    }\n    var Eb = {},\n      Fb = {};\n    function W(b, a, c) {\n      function d(g) {\n        g = c(g);\n        g.length !== b.length && yb(\"Mismatched type converter count\");\n        for (var l = 0; l < b.length; ++l) X(b[l], g[l]);\n      }\n      b.forEach(function (g) {\n        Fb[g] = a;\n      });\n      var e = Array(a.length),\n        f = [],\n        h = 0;\n      a.forEach((g, l) => {\n        ib.hasOwnProperty(g) ? e[l] = ib[g] : (f.push(g), Eb.hasOwnProperty(g) || (Eb[g] = []), Eb[g].push(() => {\n          e[l] = ib[g];\n          ++h;\n          h === f.length && d(e);\n        }));\n      });\n      0 === f.length && d(e);\n    }\n    function Gb(b) {\n      switch (b) {\n        case 1:\n          return 0;\n        case 2:\n          return 1;\n        case 4:\n          return 2;\n        case 8:\n          return 3;\n        default:\n          throw new TypeError(`Unknown type size: ${b}`);\n      }\n    }\n    function Hb(b, a, c = {}) {\n      var d = a.name;\n      b || Q(`type \"${d}\" must have a positive integer typeid pointer`);\n      if (ib.hasOwnProperty(b)) {\n        if (c.vb) return;\n        Q(`Cannot register type '${d}' twice`);\n      }\n      ib[b] = a;\n      delete Fb[b];\n      Eb.hasOwnProperty(b) && (a = Eb[b], delete Eb[b], a.forEach(e => e()));\n    }\n    function X(b, a, c = {}) {\n      if (!(\"argPackAdvance\" in a)) throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n      Hb(b, a, c);\n    }\n    function Ib(b) {\n      Q(b.Y.aa.Z.name + \" instance already deleted\");\n    }\n    function Jb() {}\n    function Kb(b, a, c) {\n      if (void 0 === b[a].ca) {\n        var d = b[a];\n        b[a] = function () {\n          b[a].ca.hasOwnProperty(arguments.length) || Q(`Function '${c}' called with an invalid number of arguments (${arguments.length}) - expects one of (${b[a].ca})!`);\n          return b[a].ca[arguments.length].apply(this, arguments);\n        };\n        b[a].ca = [];\n        b[a].ca[d.oa] = d;\n      }\n    }\n    function Lb(b, a, c) {\n      m.hasOwnProperty(b) ? ((void 0 === c || void 0 !== m[b].ca && void 0 !== m[b].ca[c]) && Q(`Cannot register public name '${b}' twice`), Kb(m, b, b), m.hasOwnProperty(c) && Q(`Cannot register multiple overloads of a function with the same number of arguments (${c})!`), m[b].ca[c] = a) : (m[b] = a, void 0 !== c && (m[b].Jb = c));\n    }\n    function Mb(b, a, c, d, e, f, h, g) {\n      this.name = b;\n      this.constructor = a;\n      this.ia = c;\n      this.ma = d;\n      this.ba = e;\n      this.qb = f;\n      this.ta = h;\n      this.lb = g;\n      this.Ta = [];\n    }\n    function Nb(b, a, c) {\n      for (; a !== c;) a.ta || Q(`Expected null or instance of ${c.name}, got an instance of ${a.name}`), b = a.ta(b), a = a.ba;\n      return b;\n    }\n    function Ob(b, a) {\n      if (null === a) return this.Ca && Q(`null is not a valid ${this.name}`), 0;\n      a.Y || Q(`Cannot pass \"${Pb(a)}\" as a ${this.name}`);\n      a.Y.$ || Q(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      return Nb(a.Y.$, a.Y.aa.Z, this.Z);\n    }\n    function Qb(b, a) {\n      if (null === a) {\n        this.Ca && Q(`null is not a valid ${this.name}`);\n        if (this.wa) {\n          var c = this.Da();\n          null !== b && b.push(this.ma, c);\n          return c;\n        }\n        return 0;\n      }\n      a.Y || Q(`Cannot pass \"${Pb(a)}\" as a ${this.name}`);\n      a.Y.$ || Q(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      !this.va && a.Y.aa.va && Q(`Cannot convert argument of type ${a.Y.ha ? a.Y.ha.name : a.Y.aa.name} to parameter type ${this.name}`);\n      c = Nb(a.Y.$, a.Y.aa.Z, this.Z);\n      if (this.wa) switch (void 0 === a.Y.ea && Q(\"Passing raw pointer to smart pointer is illegal\"), this.Hb) {\n        case 0:\n          a.Y.ha === this ? c = a.Y.ea : Q(`Cannot convert argument of type ${a.Y.ha ? a.Y.ha.name : a.Y.aa.name} to parameter type ${this.name}`);\n          break;\n        case 1:\n          c = a.Y.ea;\n          break;\n        case 2:\n          if (a.Y.ha === this) c = a.Y.ea;else {\n            var d = a.clone();\n            c = this.Db(c, T(function () {\n              d[\"delete\"]();\n            }));\n            null !== b && b.push(this.ma, c);\n          }\n          break;\n        default:\n          Q(\"Unsupporting sharing policy\");\n      }\n      return c;\n    }\n    function Rb(b, a) {\n      if (null === a) return this.Ca && Q(`null is not a valid ${this.name}`), 0;\n      a.Y || Q(`Cannot pass \"${Pb(a)}\" as a ${this.name}`);\n      a.Y.$ || Q(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      a.Y.aa.va && Q(`Cannot convert argument of type ${a.Y.aa.name} to parameter type ${this.name}`);\n      return Nb(a.Y.$, a.Y.aa.Z, this.Z);\n    }\n    function Sb(b, a, c, d) {\n      this.name = b;\n      this.Z = a;\n      this.Ca = c;\n      this.va = d;\n      this.wa = !1;\n      this.ma = this.Db = this.Da = this.Ua = this.Hb = this.Cb = void 0;\n      void 0 !== a.ba ? this.toWireType = Qb : (this.toWireType = d ? Ob : Rb, this.ga = null);\n    }\n    function Tb(b, a, c) {\n      m.hasOwnProperty(b) || yb(\"Replacing nonexistant public symbol\");\n      void 0 !== m[b].ca && void 0 !== c ? m[b].ca[c] = a : (m[b] = a, m[b].oa = c);\n    }\n    var Ub = (b, a) => {\n      var c = [];\n      return function () {\n        c.length = 0;\n        Object.assign(c, arguments);\n        if (b.includes(\"j\")) {\n          var d = m[\"dynCall_\" + b];\n          d = c && c.length ? d.apply(null, [a].concat(c)) : d.call(null, a);\n        } else d = Ga.get(a).apply(null, c);\n        return d;\n      };\n    };\n    function Z(b, a) {\n      b = V(b);\n      var c = b.includes(\"j\") ? Ub(b, a) : Ga.get(a);\n      \"function\" != typeof c && Q(`unknown function pointer with signature ${b}: ${a}`);\n      return c;\n    }\n    var Vb = void 0;\n    function Wb(b, a) {\n      function c(f) {\n        e[f] || ib[f] || (Fb[f] ? Fb[f].forEach(c) : (d.push(f), e[f] = !0));\n      }\n      var d = [],\n        e = {};\n      a.forEach(c);\n      throw new Vb(`${b}: ` + d.map(jb).join([\", \"]));\n    }\n    function Xb(b, a, c, d, e) {\n      var f = a.length;\n      2 > f && Q(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      var h = null !== a[1] && null !== c,\n        g = !1;\n      for (c = 1; c < a.length; ++c) if (null !== a[c] && void 0 === a[c].ga) {\n        g = !0;\n        break;\n      }\n      var l = \"void\" !== a[0].name,\n        k = f - 2,\n        p = Array(k),\n        r = [],\n        t = [];\n      return function () {\n        arguments.length !== k && Q(`function ${b} called with ${arguments.length} arguments, expected ${k} args!`);\n        t.length = 0;\n        r.length = h ? 2 : 1;\n        r[0] = e;\n        if (h) {\n          var v = a[1].toWireType(t, this);\n          r[1] = v;\n        }\n        for (var q = 0; q < k; ++q) p[q] = a[q + 2].toWireType(t, arguments[q]), r.push(p[q]);\n        q = d.apply(null, r);\n        if (g) Cb(t);else for (var G = h ? 1 : 2; G < a.length; G++) {\n          var I = 1 === G ? v : p[G - 2];\n          null !== a[G].ga && a[G].ga(I);\n        }\n        v = l ? a[0].fromWireType(q) : void 0;\n        return v;\n      };\n    }\n    function Yb(b, a) {\n      for (var c = [], d = 0; d < b; d++) c.push(N[a + 4 * d >> 2]);\n      return c;\n    }\n    function Zb(b, a, c) {\n      b instanceof Object || Q(`${c} with invalid \"this\": ${b}`);\n      b instanceof a.Z.constructor || Q(`${c} incompatible with \"this\" of type ${b.constructor.name}`);\n      b.Y.$ || Q(`cannot call emscripten binding method ${c} on deleted object`);\n      return Nb(b.Y.$, b.Y.aa.Z, a.Z);\n    }\n    function $b(b) {\n      b >= O.Ga && 0 === --O.get(b).Va && O.$a(b);\n    }\n    function ac(b, a, c) {\n      switch (a) {\n        case 0:\n          return function (d) {\n            return this.fromWireType((c ? za : L)[d]);\n          };\n        case 1:\n          return function (d) {\n            return this.fromWireType((c ? Aa : Ba)[d >> 1]);\n          };\n        case 2:\n          return function (d) {\n            return this.fromWireType((c ? Ca : N)[d >> 2]);\n          };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + b);\n      }\n    }\n    function Pb(b) {\n      if (null === b) return \"null\";\n      var a = typeof b;\n      return \"object\" === a || \"array\" === a || \"function\" === a ? b.toString() : \"\" + b;\n    }\n    function bc(b, a) {\n      switch (a) {\n        case 2:\n          return function (c) {\n            return this.fromWireType(Da[c >> 2]);\n          };\n        case 3:\n          return function (c) {\n            return this.fromWireType(Ea[c >> 3]);\n          };\n        default:\n          throw new TypeError(\"Unknown float type: \" + b);\n      }\n    }\n    function cc(b, a, c) {\n      switch (a) {\n        case 0:\n          return c ? function (d) {\n            return za[d];\n          } : function (d) {\n            return L[d];\n          };\n        case 1:\n          return c ? function (d) {\n            return Aa[d >> 1];\n          } : function (d) {\n            return Ba[d >> 1];\n          };\n        case 2:\n          return c ? function (d) {\n            return Ca[d >> 2];\n          } : function (d) {\n            return N[d >> 2];\n          };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + b);\n      }\n    }\n    var ec = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0,\n      fc = (b, a, c) => {\n        var d = a + c;\n        for (c = a; b[c] && !(c >= d);) ++c;\n        if (16 < c - a && b.buffer && ec) return ec.decode(b.subarray(a, c));\n        for (d = \"\"; a < c;) {\n          var e = b[a++];\n          if (e & 128) {\n            var f = b[a++] & 63;\n            if (192 == (e & 224)) d += String.fromCharCode((e & 31) << 6 | f);else {\n              var h = b[a++] & 63;\n              e = 224 == (e & 240) ? (e & 15) << 12 | f << 6 | h : (e & 7) << 18 | f << 12 | h << 6 | b[a++] & 63;\n              65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));\n            }\n          } else d += String.fromCharCode(e);\n        }\n        return d;\n      },\n      gc = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf-16le\") : void 0,\n      hc = (b, a) => {\n        var c = b >> 1;\n        for (var d = c + a / 2; !(c >= d) && Ba[c];) ++c;\n        c <<= 1;\n        if (32 < c - b && gc) return gc.decode(L.subarray(b, c));\n        c = \"\";\n        for (d = 0; !(d >= a / 2); ++d) {\n          var e = Aa[b + 2 * d >> 1];\n          if (0 == e) break;\n          c += String.fromCharCode(e);\n        }\n        return c;\n      },\n      ic = (b, a, c) => {\n        void 0 === c && (c = 2147483647);\n        if (2 > c) return 0;\n        c -= 2;\n        var d = a;\n        c = c < 2 * b.length ? c / 2 : b.length;\n        for (var e = 0; e < c; ++e) Aa[a >> 1] = b.charCodeAt(e), a += 2;\n        Aa[a >> 1] = 0;\n        return a - d;\n      },\n      jc = b => 2 * b.length,\n      kc = (b, a) => {\n        for (var c = 0, d = \"\"; !(c >= a / 4);) {\n          var e = Ca[b + 4 * c >> 2];\n          if (0 == e) break;\n          ++c;\n          65536 <= e ? (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d += String.fromCharCode(e);\n        }\n        return d;\n      },\n      lc = (b, a, c) => {\n        void 0 === c && (c = 2147483647);\n        if (4 > c) return 0;\n        var d = a;\n        c = d + c - 4;\n        for (var e = 0; e < b.length; ++e) {\n          var f = b.charCodeAt(e);\n          if (55296 <= f && 57343 >= f) {\n            var h = b.charCodeAt(++e);\n            f = 65536 + ((f & 1023) << 10) | h & 1023;\n          }\n          Ca[a >> 2] = f;\n          a += 4;\n          if (a + 4 > c) break;\n        }\n        Ca[a >> 2] = 0;\n        return a - d;\n      },\n      mc = b => {\n        for (var a = 0, c = 0; c < b.length; ++c) {\n          var d = b.charCodeAt(c);\n          55296 <= d && 57343 >= d && ++c;\n          a += 4;\n        }\n        return a;\n      },\n      nc = {};\n    function oc(b) {\n      var a = nc[b];\n      return void 0 === a ? V(b) : a;\n    }\n    var pc = [];\n    function qc(b) {\n      var a = pc.length;\n      pc.push(b);\n      return a;\n    }\n    function rc(b, a) {\n      for (var c = Array(b), d = 0; d < b; ++d) c[d] = mb(N[a + 4 * d >> 2], \"parameter \" + d);\n      return c;\n    }\n    var sc = [],\n      tc = {},\n      vc = () => {\n        if (!uc) {\n          var b = {\n              USER: \"web_user\",\n              LOGNAME: \"web_user\",\n              PATH: \"/\",\n              PWD: \"/\",\n              HOME: \"/home/web_user\",\n              LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n              _: la || \"./this.program\"\n            },\n            a;\n          for (a in tc) void 0 === tc[a] ? delete b[a] : b[a] = tc[a];\n          var c = [];\n          for (a in b) c.push(`${a}=${b[a]}`);\n          uc = c;\n        }\n        return uc;\n      },\n      uc,\n      wc = [null, [], []];\n    Object.assign(Za.prototype, {\n      get(b) {\n        return this.la[b];\n      },\n      has(b) {\n        return void 0 !== this.la[b];\n      },\n      ab(b) {\n        var a = this.Qa.pop() || this.la.length;\n        this.la[a] = b;\n        return a;\n      },\n      $a(b) {\n        this.la[b] = void 0;\n        this.Qa.push(b);\n      }\n    });\n    $a = m.BindingError = class extends Error {\n      constructor(b) {\n        super(b);\n        this.name = \"BindingError\";\n      }\n    };\n    O.la.push({\n      value: void 0\n    }, {\n      value: null\n    }, {\n      value: !0\n    }, {\n      value: !1\n    });\n    O.Ga = O.la.length;\n    m.count_emval_handles = function () {\n      for (var b = 0, a = O.Ga; a < O.la.length; ++a) void 0 !== O.la[a] && ++b;\n      return b;\n    };\n    bb = m.PureVirtualError = ab(\"PureVirtualError\");\n    for (var xc = Array(256), yc = 0; 256 > yc; ++yc) xc[yc] = String.fromCharCode(yc);\n    cb = xc;\n    m.getInheritedInstanceCount = function () {\n      return Object.keys(gb).length;\n    };\n    m.getLiveInheritedInstances = function () {\n      var b = [],\n        a;\n      for (a in gb) gb.hasOwnProperty(a) && b.push(gb[a]);\n      return b;\n    };\n    m.flushPendingDeletes = eb;\n    m.setDelayFunction = function (b) {\n      fb = b;\n      db.length && fb && fb(eb);\n    };\n    xb = m.InternalError = class extends Error {\n      constructor(b) {\n        super(b);\n        this.name = \"InternalError\";\n      }\n    };\n    Jb.prototype.isAliasOf = function (b) {\n      if (!(this instanceof Jb && b instanceof Jb)) return !1;\n      var a = this.Y.aa.Z,\n        c = this.Y.$,\n        d = b.Y.aa.Z;\n      for (b = b.Y.$; a.ba;) c = a.ta(c), a = a.ba;\n      for (; d.ba;) b = d.ta(b), d = d.ba;\n      return a === d && c === b;\n    };\n    Jb.prototype.clone = function () {\n      this.Y.$ || Ib(this);\n      if (this.Y.ra) return this.Y.count.value += 1, this;\n      var b = Ab,\n        a = Object,\n        c = a.create,\n        d = Object.getPrototypeOf(this),\n        e = this.Y;\n      b = b(c.call(a, d, {\n        Y: {\n          value: {\n            count: e.count,\n            pa: e.pa,\n            ra: e.ra,\n            $: e.$,\n            aa: e.aa,\n            ea: e.ea,\n            ha: e.ha\n          }\n        }\n      }));\n      b.Y.count.value += 1;\n      b.Y.pa = !1;\n      return b;\n    };\n    Jb.prototype[\"delete\"] = function () {\n      this.Y.$ || Ib(this);\n      this.Y.pa && !this.Y.ra && Q(\"Object already scheduled for deletion\");\n      nb(this);\n      tb(this.Y);\n      this.Y.ra || (this.Y.ea = void 0, this.Y.$ = void 0);\n    };\n    Jb.prototype.isDeleted = function () {\n      return !this.Y.$;\n    };\n    Jb.prototype.deleteLater = function () {\n      this.Y.$ || Ib(this);\n      this.Y.pa && !this.Y.ra && Q(\"Object already scheduled for deletion\");\n      db.push(this);\n      1 === db.length && fb && fb(eb);\n      this.Y.pa = !0;\n      return this;\n    };\n    Sb.prototype.rb = function (b) {\n      this.Ua && (b = this.Ua(b));\n      return b;\n    };\n    Sb.prototype.Ma = function (b) {\n      this.ma && this.ma(b);\n    };\n    Sb.prototype.argPackAdvance = 8;\n    Sb.prototype.readValueFromPointer = Db;\n    Sb.prototype.deleteObject = function (b) {\n      if (null !== b) b[\"delete\"]();\n    };\n    Sb.prototype.fromWireType = function (b) {\n      function a() {\n        return this.wa ? zb(this.Z.ia, {\n          aa: this.Cb,\n          $: c,\n          ha: this,\n          ea: b\n        }) : zb(this.Z.ia, {\n          aa: this,\n          $: b\n        });\n      }\n      var c = this.rb(b);\n      if (!c) return this.Ma(b), null;\n      var d = wb(this.Z, c);\n      if (void 0 !== d) {\n        if (0 === d.Y.count.value) return d.Y.$ = c, d.Y.ea = b, d.clone();\n        d = d.clone();\n        this.Ma(b);\n        return d;\n      }\n      d = this.Z.qb(c);\n      d = vb[d];\n      if (!d) return a.call(this);\n      d = this.va ? d.hb : d.pointerType;\n      var e = ub(c, this.Z, d.Z);\n      return null === e ? a.call(this) : this.wa ? zb(d.Z.ia, {\n        aa: d,\n        $: e,\n        ha: this,\n        ea: b\n      }) : zb(d.Z.ia, {\n        aa: d,\n        $: e\n      });\n    };\n    Vb = m.UnboundTypeError = ab(\"UnboundTypeError\");\n    var Ac = {\n      L: function (b, a, c) {\n        b = V(b);\n        a = mb(a, \"wrapper\");\n        c = S(c);\n        var d = [].slice,\n          e = a.Z,\n          f = e.ia,\n          h = e.ba.ia,\n          g = e.ba.constructor;\n        b = Ya(b, function () {\n          e.ba.Ta.forEach(function (k) {\n            if (this[k] === h[k]) throw new bb(`Pure virtual function ${k} must be implemented in JavaScript`);\n          }.bind(this));\n          Object.defineProperty(this, \"__parent\", {\n            value: f\n          });\n          this.__construct.apply(this, d.call(arguments));\n        });\n        f.__construct = function () {\n          this === f && Q(\"Pass correct 'this' to __construct\");\n          var k = g.implement.apply(void 0, [this].concat(d.call(arguments)));\n          nb(k);\n          var p = k.Y;\n          k.notifyOnDestruction();\n          p.ra = !0;\n          Object.defineProperties(this, {\n            Y: {\n              value: p\n            }\n          });\n          Ab(this);\n          k = p.$;\n          k = hb(e, k);\n          gb.hasOwnProperty(k) ? Q(`Tried to register registered instance: ${k}`) : gb[k] = this;\n        };\n        f.__destruct = function () {\n          this === f && Q(\"Pass correct 'this' to __destruct\");\n          nb(this);\n          var k = this.Y.$;\n          k = hb(e, k);\n          gb.hasOwnProperty(k) ? delete gb[k] : Q(`Tried to unregister unregistered instance: ${k}`);\n        };\n        b.prototype = Object.create(f);\n        for (var l in c) b.prototype[l] = c[l];\n        return T(b);\n      },\n      N: function (b) {\n        var a = Bb[b];\n        delete Bb[b];\n        var c = a.Da,\n          d = a.ma,\n          e = a.Pa,\n          f = e.map(h => h.ub).concat(e.map(h => h.Fb));\n        W([b], f, h => {\n          var g = {};\n          e.forEach((l, k) => {\n            var p = h[k],\n              r = l.sb,\n              t = l.tb,\n              v = h[k + e.length],\n              q = l.Eb,\n              G = l.Gb;\n            g[l.ob] = {\n              read: I => p.fromWireType(r(t, I)),\n              write: (I, w) => {\n                var z = [];\n                q(G, I, v.toWireType(z, w));\n                Cb(z);\n              }\n            };\n          });\n          return [{\n            name: a.name,\n            fromWireType: function (l) {\n              var k = {},\n                p;\n              for (p in g) k[p] = g[p].read(l);\n              d(l);\n              return k;\n            },\n            toWireType: function (l, k) {\n              for (var p in g) if (!(p in k)) throw new TypeError(`Missing field: \"${p}\"`);\n              var r = c();\n              for (p in g) g[p].write(r, k[p]);\n              null !== l && l.push(d, r);\n              return r;\n            },\n            argPackAdvance: 8,\n            readValueFromPointer: Db,\n            ga: d\n          }];\n        });\n      },\n      C: function () {},\n      J: function (b, a, c, d, e) {\n        var f = Gb(c);\n        a = V(a);\n        X(b, {\n          name: a,\n          fromWireType: function (h) {\n            return !!h;\n          },\n          toWireType: function (h, g) {\n            return g ? d : e;\n          },\n          argPackAdvance: 8,\n          readValueFromPointer: function (h) {\n            if (1 === c) var g = za;else if (2 === c) g = Aa;else if (4 === c) g = Ca;else throw new TypeError(\"Unknown boolean type size: \" + a);\n            return this.fromWireType(g[h >> f]);\n          },\n          ga: null\n        });\n      },\n      f: function (b, a, c, d, e, f, h, g, l, k, p, r, t) {\n        p = V(p);\n        f = Z(e, f);\n        g && (g = Z(h, g));\n        k && (k = Z(l, k));\n        t = Z(r, t);\n        var v = Wa(p);\n        Lb(v, function () {\n          Wb(`Cannot construct ${p} due to unbound types`, [d]);\n        });\n        W([b, a, c], d ? [d] : [], function (q) {\n          q = q[0];\n          if (d) {\n            var G = q.Z;\n            var I = G.ia;\n          } else I = Jb.prototype;\n          q = Ya(v, function () {\n            if (Object.getPrototypeOf(this) !== w) throw new $a(\"Use 'new' to construct \" + p);\n            if (void 0 === z.na) throw new $a(p + \" has no accessible constructor\");\n            var P = z.na[arguments.length];\n            if (void 0 === P) throw new $a(`Tried to invoke ctor of ${p} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(z.na).toString()}) parameters instead!`);\n            return P.apply(this, arguments);\n          });\n          var w = Object.create(I, {\n            constructor: {\n              value: q\n            }\n          });\n          q.prototype = w;\n          var z = new Mb(p, q, w, t, G, f, g, k);\n          z.ba && (void 0 === z.ba.ua && (z.ba.ua = []), z.ba.ua.push(z));\n          G = new Sb(p, z, !0, !1);\n          I = new Sb(p + \"*\", z, !1, !1);\n          var J = new Sb(p + \" const*\", z, !1, !0);\n          vb[b] = {\n            pointerType: I,\n            hb: J\n          };\n          Tb(v, q);\n          return [G, I, J];\n        });\n      },\n      l: function (b, a, c, d, e, f, h) {\n        var g = Yb(c, d);\n        a = V(a);\n        f = Z(e, f);\n        W([], [b], function (l) {\n          function k() {\n            Wb(`Cannot call ${p} due to unbound types`, g);\n          }\n          l = l[0];\n          var p = `${l.name}.${a}`;\n          a.startsWith(\"@@\") && (a = Symbol[a.substring(2)]);\n          var r = l.Z.constructor;\n          void 0 === r[a] ? (k.oa = c - 1, r[a] = k) : (Kb(r, a, p), r[a].ca[c - 1] = k);\n          W([], g, function (t) {\n            t = Xb(p, [t[0], null].concat(t.slice(1)), null, f, h);\n            void 0 === r[a].ca ? (t.oa = c - 1, r[a] = t) : r[a].ca[c - 1] = t;\n            if (l.Z.ua) for (const v of l.Z.ua) v.constructor.hasOwnProperty(a) || (v.constructor[a] = t);\n            return [];\n          });\n          return [];\n        });\n      },\n      w: function (b, a, c, d, e, f, h, g) {\n        a = V(a);\n        f = Z(e, f);\n        W([], [b], function (l) {\n          l = l[0];\n          var k = `${l.name}.${a}`,\n            p = {\n              get() {\n                Wb(`Cannot access ${k} due to unbound types`, [c]);\n              },\n              enumerable: !0,\n              configurable: !0\n            };\n          p.set = g ? () => {\n            Wb(`Cannot access ${k} due to unbound types`, [c]);\n          } : () => {\n            Q(`${k} is a read-only property`);\n          };\n          Object.defineProperty(l.Z.constructor, a, p);\n          W([], [c], function (r) {\n            r = r[0];\n            var t = {\n              get() {\n                return r.fromWireType(f(d));\n              },\n              enumerable: !0\n            };\n            g && (g = Z(h, g), t.set = v => {\n              var q = [];\n              g(d, r.toWireType(q, v));\n              Cb(q);\n            });\n            Object.defineProperty(l.Z.constructor, a, t);\n            return [];\n          });\n          return [];\n        });\n      },\n      r: function (b, a, c, d, e, f) {\n        var h = Yb(a, c);\n        e = Z(d, e);\n        W([], [b], function (g) {\n          g = g[0];\n          var l = `constructor ${g.name}`;\n          void 0 === g.Z.na && (g.Z.na = []);\n          if (void 0 !== g.Z.na[a - 1]) throw new $a(`Cannot register multiple constructors with identical number of parameters (${a - 1}) for class '${g.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n          g.Z.na[a - 1] = () => {\n            Wb(`Cannot construct ${g.name} due to unbound types`, h);\n          };\n          W([], h, function (k) {\n            k.splice(1, 0, null);\n            g.Z.na[a - 1] = Xb(l, k, null, e, f);\n            return [];\n          });\n          return [];\n        });\n      },\n      b: function (b, a, c, d, e, f, h, g) {\n        var l = Yb(c, d);\n        a = V(a);\n        f = Z(e, f);\n        W([], [b], function (k) {\n          function p() {\n            Wb(`Cannot call ${r} due to unbound types`, l);\n          }\n          k = k[0];\n          var r = `${k.name}.${a}`;\n          a.startsWith(\"@@\") && (a = Symbol[a.substring(2)]);\n          g && k.Z.Ta.push(a);\n          var t = k.Z.ia,\n            v = t[a];\n          void 0 === v || void 0 === v.ca && v.className !== k.name && v.oa === c - 2 ? (p.oa = c - 2, p.className = k.name, t[a] = p) : (Kb(t, a, r), t[a].ca[c - 2] = p);\n          W([], l, function (q) {\n            q = Xb(r, q, k, f, h);\n            void 0 === t[a].ca ? (q.oa = c - 2, t[a] = q) : t[a].ca[c - 2] = q;\n            return [];\n          });\n          return [];\n        });\n      },\n      e: function (b, a, c, d, e, f, h, g, l, k) {\n        a = V(a);\n        e = Z(d, e);\n        W([], [b], function (p) {\n          p = p[0];\n          var r = `${p.name}.${a}`,\n            t = {\n              get() {\n                Wb(`Cannot access ${r} due to unbound types`, [c, h]);\n              },\n              enumerable: !0,\n              configurable: !0\n            };\n          t.set = l ? () => {\n            Wb(`Cannot access ${r} due to unbound types`, [c, h]);\n          } : () => {\n            Q(r + \" is a read-only property\");\n          };\n          Object.defineProperty(p.Z.ia, a, t);\n          W([], l ? [c, h] : [c], function (v) {\n            var q = v[0],\n              G = {\n                get() {\n                  var w = Zb(this, p, r + \" getter\");\n                  return q.fromWireType(e(f, w));\n                },\n                enumerable: !0\n              };\n            if (l) {\n              l = Z(g, l);\n              var I = v[1];\n              G.set = function (w) {\n                var z = Zb(this, p, r + \" setter\"),\n                  J = [];\n                l(k, z, I.toWireType(J, w));\n                Cb(J);\n              };\n            }\n            Object.defineProperty(p.Z.ia, a, G);\n            return [];\n          });\n          return [];\n        });\n      },\n      I: function (b, a) {\n        a = V(a);\n        X(b, {\n          name: a,\n          fromWireType: function (c) {\n            var d = S(c);\n            $b(c);\n            return d;\n          },\n          toWireType: function (c, d) {\n            return T(d);\n          },\n          argPackAdvance: 8,\n          readValueFromPointer: Db,\n          ga: null\n        });\n      },\n      o: function (b, a, c, d) {\n        function e() {}\n        c = Gb(c);\n        a = V(a);\n        e.values = {};\n        X(b, {\n          name: a,\n          constructor: e,\n          fromWireType: function (f) {\n            return this.constructor.values[f];\n          },\n          toWireType: function (f, h) {\n            return h.value;\n          },\n          argPackAdvance: 8,\n          readValueFromPointer: ac(a, c, d),\n          ga: null\n        });\n        Lb(a, e);\n      },\n      c: function (b, a, c) {\n        var d = mb(b, \"enum\");\n        a = V(a);\n        b = d.constructor;\n        d = Object.create(d.constructor.prototype, {\n          value: {\n            value: c\n          },\n          constructor: {\n            value: Ya(`${d.name}_${a}`, function () {})\n          }\n        });\n        b.values[c] = d;\n        b[a] = d;\n      },\n      y: function (b, a, c) {\n        c = Gb(c);\n        a = V(a);\n        X(b, {\n          name: a,\n          fromWireType: function (d) {\n            return d;\n          },\n          toWireType: function (d, e) {\n            return e;\n          },\n          argPackAdvance: 8,\n          readValueFromPointer: bc(a, c),\n          ga: null\n        });\n      },\n      t: function (b, a, c, d, e, f) {\n        var h = Yb(a, c);\n        b = V(b);\n        e = Z(d, e);\n        Lb(b, function () {\n          Wb(`Cannot call ${b} due to unbound types`, h);\n        }, a - 1);\n        W([], h, function (g) {\n          Tb(b, Xb(b, [g[0], null].concat(g.slice(1)), null, e, f), a - 1);\n          return [];\n        });\n      },\n      k: function (b, a, c, d, e) {\n        a = V(a);\n        -1 === e && (e = 4294967295);\n        e = Gb(c);\n        var f = g => g;\n        if (0 === d) {\n          var h = 32 - 8 * c;\n          f = g => g << h >>> h;\n        }\n        c = a.includes(\"unsigned\") ? function (g, l) {\n          return l >>> 0;\n        } : function (g, l) {\n          return l;\n        };\n        X(b, {\n          name: a,\n          fromWireType: f,\n          toWireType: c,\n          argPackAdvance: 8,\n          readValueFromPointer: cc(a, e, 0 !== d),\n          ga: null\n        });\n      },\n      g: function (b, a, c) {\n        function d(f) {\n          f >>= 2;\n          var h = N;\n          return new e(h.buffer, h[f + 1], h[f]);\n        }\n        var e = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][a];\n        c = V(c);\n        X(b, {\n          name: c,\n          fromWireType: d,\n          argPackAdvance: 8,\n          readValueFromPointer: d\n        }, {\n          vb: !0\n        });\n      },\n      z: function (b, a) {\n        a = V(a);\n        var c = \"std::string\" === a;\n        X(b, {\n          name: a,\n          fromWireType: function (d) {\n            var e = N[d >> 2],\n              f = d + 4;\n            if (c) for (var h = f, g = 0; g <= e; ++g) {\n              var l = f + g;\n              if (g == e || 0 == L[l]) {\n                h = h ? fc(L, h, l - h) : \"\";\n                if (void 0 === k) var k = h;else k += String.fromCharCode(0), k += h;\n                h = l + 1;\n              }\n            } else {\n              k = Array(e);\n              for (g = 0; g < e; ++g) k[g] = String.fromCharCode(L[f + g]);\n              k = k.join(\"\");\n            }\n            lb(d);\n            return k;\n          },\n          toWireType: function (d, e) {\n            e instanceof ArrayBuffer && (e = new Uint8Array(e));\n            var f,\n              h = \"string\" == typeof e;\n            h || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || Q(\"Cannot pass non-string to std::string\");\n            var g;\n            if (c && h) for (f = g = 0; f < e.length; ++f) {\n              var l = e.charCodeAt(f);\n              127 >= l ? g++ : 2047 >= l ? g += 2 : 55296 <= l && 57343 >= l ? (g += 4, ++f) : g += 3;\n            } else g = e.length;\n            f = g;\n            g = zc(4 + f + 1);\n            l = g + 4;\n            N[g >> 2] = f;\n            if (c && h) {\n              if (h = l, l = f + 1, f = L, 0 < l) {\n                l = h + l - 1;\n                for (var k = 0; k < e.length; ++k) {\n                  var p = e.charCodeAt(k);\n                  if (55296 <= p && 57343 >= p) {\n                    var r = e.charCodeAt(++k);\n                    p = 65536 + ((p & 1023) << 10) | r & 1023;\n                  }\n                  if (127 >= p) {\n                    if (h >= l) break;\n                    f[h++] = p;\n                  } else {\n                    if (2047 >= p) {\n                      if (h + 1 >= l) break;\n                      f[h++] = 192 | p >> 6;\n                    } else {\n                      if (65535 >= p) {\n                        if (h + 2 >= l) break;\n                        f[h++] = 224 | p >> 12;\n                      } else {\n                        if (h + 3 >= l) break;\n                        f[h++] = 240 | p >> 18;\n                        f[h++] = 128 | p >> 12 & 63;\n                      }\n                      f[h++] = 128 | p >> 6 & 63;\n                    }\n                    f[h++] = 128 | p & 63;\n                  }\n                }\n                f[h] = 0;\n              }\n            } else if (h) for (h = 0; h < f; ++h) k = e.charCodeAt(h), 255 < k && (lb(l), Q(\"String has UTF-16 code units that do not fit in 8 bits\")), L[l + h] = k;else for (h = 0; h < f; ++h) L[l + h] = e[h];\n            null !== d && d.push(lb, g);\n            return g;\n          },\n          argPackAdvance: 8,\n          readValueFromPointer: Db,\n          ga: function (d) {\n            lb(d);\n          }\n        });\n      },\n      v: function (b, a, c) {\n        c = V(c);\n        if (2 === a) {\n          var d = hc;\n          var e = ic;\n          var f = jc;\n          var h = () => Ba;\n          var g = 1;\n        } else 4 === a && (d = kc, e = lc, f = mc, h = () => N, g = 2);\n        X(b, {\n          name: c,\n          fromWireType: function (l) {\n            for (var k = N[l >> 2], p = h(), r, t = l + 4, v = 0; v <= k; ++v) {\n              var q = l + 4 + v * a;\n              if (v == k || 0 == p[q >> g]) t = d(t, q - t), void 0 === r ? r = t : (r += String.fromCharCode(0), r += t), t = q + a;\n            }\n            lb(l);\n            return r;\n          },\n          toWireType: function (l, k) {\n            \"string\" != typeof k && Q(`Cannot pass non-string to C++ string type ${c}`);\n            var p = f(k),\n              r = zc(4 + p + a);\n            N[r >> 2] = p >> g;\n            e(k, r + 4, p + a);\n            null !== l && l.push(lb, r);\n            return r;\n          },\n          argPackAdvance: 8,\n          readValueFromPointer: Db,\n          ga: function (l) {\n            lb(l);\n          }\n        });\n      },\n      P: function (b, a, c, d, e, f) {\n        Bb[b] = {\n          name: V(a),\n          Da: Z(c, d),\n          ma: Z(e, f),\n          Pa: []\n        };\n      },\n      O: function (b, a, c, d, e, f, h, g, l, k) {\n        Bb[b].Pa.push({\n          ob: V(a),\n          ub: c,\n          sb: Z(d, e),\n          tb: f,\n          Fb: h,\n          Eb: Z(g, l),\n          Gb: k\n        });\n      },\n      K: function (b, a) {\n        a = V(a);\n        X(b, {\n          xb: !0,\n          name: a,\n          argPackAdvance: 0,\n          fromWireType: function () {},\n          toWireType: function () {}\n        });\n      },\n      u: function (b, a, c) {\n        b = S(b);\n        a = mb(a, \"emval::as\");\n        var d = [],\n          e = T(d);\n        N[c >> 2] = e;\n        return a.toWireType(d, b);\n      },\n      A: function (b, a, c, d, e) {\n        b = pc[b];\n        a = S(a);\n        c = oc(c);\n        var f = [];\n        N[d >> 2] = T(f);\n        return b(a, c, f, e);\n      },\n      i: function (b, a, c, d) {\n        b = pc[b];\n        a = S(a);\n        c = oc(c);\n        b(a, c, null, d);\n      },\n      d: $b,\n      h: function (b, a) {\n        var c = rc(b, a),\n          d = c[0];\n        a = d.name + \"_$\" + c.slice(1).map(function (h) {\n          return h.name;\n        }).join(\"_\") + \"$\";\n        var e = sc[a];\n        if (void 0 !== e) return e;\n        var f = Array(b - 1);\n        e = qc((h, g, l, k) => {\n          for (var p = 0, r = 0; r < b - 1; ++r) f[r] = c[r + 1].readValueFromPointer(k + p), p += c[r + 1].argPackAdvance;\n          h = h[g].apply(h, f);\n          for (r = 0; r < b - 1; ++r) c[r + 1].jb && c[r + 1].jb(f[r]);\n          if (!d.xb) return d.toWireType(l, h);\n        });\n        return sc[a] = e;\n      },\n      s: function (b) {\n        b = oc(b);\n        return T(m[b]);\n      },\n      M: function (b, a) {\n        b = S(b);\n        a = S(a);\n        return T(b[a]);\n      },\n      n: function (b) {\n        4 < b && (O.get(b).Va += 1);\n      },\n      m: function (b) {\n        return T(oc(b));\n      },\n      x: function () {\n        return T({});\n      },\n      p: function (b) {\n        var a = S(b);\n        Cb(a);\n        $b(b);\n      },\n      j: function (b, a, c) {\n        b = S(b);\n        a = S(a);\n        c = S(c);\n        b[a] = c;\n      },\n      q: function (b, a) {\n        b = mb(b, \"_emval_take_value\");\n        b = b.readValueFromPointer(a);\n        return T(b);\n      },\n      a: () => {\n        wa(\"\");\n      },\n      D: b => {\n        var a = L.length;\n        b >>>= 0;\n        if (2147483648 < b) return !1;\n        for (var c = 1; 4 >= c; c *= 2) {\n          var d = a * (1 + .2 / c);\n          d = Math.min(d, b + 100663296);\n          var e = Math;\n          d = Math.max(b, d);\n          a: {\n            e = e.min.call(e, 2147483648, d + (65536 - d % 65536) % 65536) - xa.buffer.byteLength + 65535 >>> 16;\n            try {\n              xa.grow(e);\n              Fa();\n              var f = 1;\n              break a;\n            } catch (h) {}\n            f = void 0;\n          }\n          if (f) return !0;\n        }\n        return !1;\n      },\n      E: (b, a) => {\n        var c = 0;\n        vc().forEach(function (d, e) {\n          var f = a + c;\n          e = N[b + 4 * e >> 2] = f;\n          for (f = 0; f < d.length; ++f) za[e++ >> 0] = d.charCodeAt(f);\n          za[e >> 0] = 0;\n          c += d.length + 1;\n        });\n        return 0;\n      },\n      F: (b, a) => {\n        var c = vc();\n        N[b >> 2] = c.length;\n        var d = 0;\n        c.forEach(function (e) {\n          d += e.length + 1;\n        });\n        N[a >> 2] = d;\n        return 0;\n      },\n      G: () => 52,\n      B: function () {\n        return 70;\n      },\n      H: (b, a, c, d) => {\n        for (var e = 0, f = 0; f < c; f++) {\n          var h = N[a >> 2],\n            g = N[a + 4 >> 2];\n          a += 8;\n          for (var l = 0; l < g; l++) {\n            var k = L[h + l],\n              p = wc[b];\n            0 === k || 10 === k ? ((1 === b ? ra : sa)(fc(p, 0)), p.length = 0) : p.push(k);\n          }\n          e += g;\n        }\n        N[d >> 2] = e;\n        return 0;\n      }\n    };\n    (function () {\n      function b(c) {\n        H = c = c.exports;\n        xa = H.Q;\n        Fa();\n        Ga = H.W;\n        Ia.unshift(H.R);\n        La--;\n        m.monitorRunDependencies && m.monitorRunDependencies(La);\n        if (0 == La && (null !== Ma && (clearInterval(Ma), Ma = null), Na)) {\n          var d = Na;\n          Na = null;\n          d();\n        }\n        return c;\n      }\n      var a = {\n        a: Ac\n      };\n      La++;\n      m.monitorRunDependencies && m.monitorRunDependencies(La);\n      if (m.instantiateWasm) try {\n        return m.instantiateWasm(a, b);\n      } catch (c) {\n        sa(\"Module.instantiateWasm callback failed with error: \" + c), ba(c);\n      }\n      Ua(a, function (c) {\n        b(c.instance);\n      }).catch(ba);\n      return {};\n    })();\n    var lb = b => (lb = H.S)(b),\n      zc = b => (zc = H.T)(b),\n      kb = b => (kb = H.U)(b);\n    m.__embind_initialize_bindings = () => (m.__embind_initialize_bindings = H.V)();\n    m.dynCall_jiji = (b, a, c, d, e) => (m.dynCall_jiji = H.X)(b, a, c, d, e);\n    var Bc;\n    Na = function Cc() {\n      Bc || Dc();\n      Bc || (Na = Cc);\n    };\n    function Dc() {\n      function b() {\n        if (!Bc && (Bc = !0, m.calledRun = !0, !ya)) {\n          Va(Ia);\n          aa(m);\n          if (m.onRuntimeInitialized) m.onRuntimeInitialized();\n          if (m.postRun) for (\"function\" == typeof m.postRun && (m.postRun = [m.postRun]); m.postRun.length;) {\n            var a = m.postRun.shift();\n            Ja.unshift(a);\n          }\n          Va(Ja);\n        }\n      }\n      if (!(0 < La)) {\n        if (m.preRun) for (\"function\" == typeof m.preRun && (m.preRun = [m.preRun]); m.preRun.length;) Ka();\n        Va(Ha);\n        0 < La || (m.setStatus ? (m.setStatus(\"Running...\"), setTimeout(function () {\n          setTimeout(function () {\n            m.setStatus(\"\");\n          }, 1);\n          b();\n        }, 1)) : b());\n      }\n    }\n    if (m.preInit) for (\"function\" == typeof m.preInit && (m.preInit = [m.preInit]); 0 < m.preInit.length;) m.preInit.pop()();\n    Dc();\n    return moduleArg.ready;\n  };\n})();\nexport default Rive;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}