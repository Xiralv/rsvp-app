{"ast":null,"code":"import _asyncToGenerator from \"/Users/vlarix/Documents/mobile-apps/rsvp-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, EventEmitter, Directive, Input, Output, HostListener, forwardRef, ContentChildren, NgModule } from '@angular/core';\nimport { Observable, firstValueFrom, BehaviorSubject, from, of, merge } from 'rxjs';\nimport { share, filter, distinctUntilChanged, switchMap, shareReplay, tap, map } from 'rxjs/operators';\nimport RiveBuilder from '@rive-app/canvas-advanced';\nimport * as i1 from '@angular/common/http';\nimport { HttpClientModule } from '@angular/common/http';\nconst nextFrame = rive => {\n  return new Promise(res => {\n    rive.requestAnimationFrame(res);\n  });\n};\n// Observable that trigger on every frame\nconst animationFrame = rive => new Observable(subscriber => {\n  let start = 0;\n  let first = true;\n  const run = time => {\n    const delta = time - start;\n    start = time;\n    if (first) {\n      subscriber.next(16);\n      first = false;\n    } else {\n      subscriber.next(delta);\n    }\n    // Because of bug in Chrome first value might be too big and cause issues\n    if (subscriber.closed) return;\n    rive.requestAnimationFrame(run);\n  };\n  rive.requestAnimationFrame(run);\n});\nconst RIVE_FOLDER = new InjectionToken('Folder with Rive files');\nconst RIVE_VERSION = new InjectionToken('Version used to load rive WASM');\nconst RIVE_WASM = new InjectionToken('Local path to rive WASM');\nlet RiveService = /*#__PURE__*/(() => {\n  var _RiveService;\n  class RiveService {\n    constructor(http, folder, wasmPath, version) {\n      this.http = http;\n      const riveVersion = version !== null && version !== void 0 ? version : '2.4.0';\n      this.folder = folder !== null && folder !== void 0 ? folder : 'assets/rive';\n      this.wasmPath = wasmPath !== null && wasmPath !== void 0 ? wasmPath : `https://unpkg.com/@rive-app/canvas-advanced@${riveVersion}/rive.wasm`;\n    }\n    getRive() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!_this.rive) {\n          const locateFile = () => _this.wasmPath;\n          _this.rive = yield RiveBuilder({\n            locateFile\n          });\n          _this.frame = animationFrame(_this.rive).pipe(share());\n        }\n        return _this.rive;\n      })();\n    }\n    getAsset(asset) {\n      return firstValueFrom(this.http.get(asset, {\n        responseType: 'arraybuffer'\n      }));\n    }\n    /** Load a riv file */\n    load(file) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        // Provide the file directly\n        if (typeof file !== 'string') {\n          const [rive, buffer] = yield Promise.all([_this2.getRive(), file.arrayBuffer()]);\n          return rive === null || rive === void 0 ? void 0 : rive.load(new Uint8Array(buffer));\n        }\n        const asset = `${_this2.folder}/${file}.riv`;\n        const [rive, buffer] = yield Promise.all([_this2.getRive(), _this2.getAsset(asset)]);\n        if (!rive) throw new Error('Could not load rive');\n        return rive.load(new Uint8Array(buffer));\n      })();\n    }\n  }\n  _RiveService = RiveService;\n  _RiveService.ɵfac = function _RiveService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(RIVE_FOLDER, 8), i0.ɵɵinject(RIVE_WASM, 8), i0.ɵɵinject(RIVE_VERSION, 8));\n  };\n  _RiveService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _RiveService,\n    factory: _RiveService.ɵfac,\n    providedIn: 'root'\n  });\n  return RiveService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction toInt(value) {\n  const v = typeof value === 'string' ? parseInt(value) : value;\n  if (typeof v !== 'number') return;\n  return v;\n}\nfunction toFloat(value) {\n  const v = typeof value === 'string' ? parseFloat(value) : value;\n  if (typeof v !== 'number') return;\n  return v;\n}\nfunction toBool(value) {\n  if (value === '' || value === true) return true;\n  if (value === false) return false;\n  return;\n}\nfunction getAnimations(artboard) {\n  const animations = [];\n  if (!artboard) return [];\n  const max = artboard.animationCount();\n  for (let i = 0; i < max; i++) {\n    animations.push(artboard.animationByIndex(i));\n  }\n  return animations;\n}\nfunction getStateMachines(artboard) {\n  const stateMachines = [];\n  if (!artboard) return [];\n  const max = artboard.stateMachineCount();\n  for (let i = 0; i < max; i++) {\n    stateMachines.push(artboard.stateMachineByIndex(i));\n  }\n  return stateMachines;\n}\nfunction getClientCoordinates(event) {\n  var _event$touches, _event$changedTouches;\n  if ([\"touchstart\", \"touchmove\"].indexOf(event.type) > -1 && (_event$touches = event.touches) !== null && _event$touches !== void 0 && _event$touches.length) {\n    event.preventDefault();\n    return {\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    };\n  } else if (event.type === \"touchend\" && (_event$changedTouches = event.changedTouches) !== null && _event$changedTouches !== void 0 && _event$changedTouches.length) {\n    return {\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    };\n  } else {\n    return {\n      clientX: event.clientX,\n      clientY: event.clientY\n    };\n  }\n}\n;\nconst exist$3 = v => v !== null && v !== undefined;\nconst onVisible = element => new Promise((res, rej) => {\n  // SSR\n  if (typeof window === 'undefined') {\n    return res(false);\n  }\n  // Compatibility\n  if (!('IntersectionObserver' in window)) {\n    return res(true);\n  }\n  let isVisible = false;\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const visible = entry.intersectionRatio !== 0;\n      if (visible !== isVisible) {\n        res(isVisible);\n        observer.disconnect();\n      }\n    });\n  }, {\n    threshold: [0]\n  });\n  // start observing element visibility\n  observer.observe(element);\n});\n// Force event to run inside zones\nfunction enterZone(zone) {\n  return source => new Observable(observer => source.subscribe({\n    next: x => zone.run(() => observer.next(x)),\n    error: err => observer.error(err),\n    complete: () => observer.complete()\n  }));\n}\nlet RiveCanvas = /*#__PURE__*/(() => {\n  var _RiveCanvas;\n  class RiveCanvas {\n    set riv(url) {\n      this.url.next(url);\n    }\n    set name(name) {\n      this.arboardName.next(name);\n    }\n    set width(w) {\n      var _toInt;\n      const width = (_toInt = toInt(w)) !== null && _toInt !== void 0 ? _toInt : this.canvas.width;\n      this.canvas.width = width;\n    }\n    get width() {\n      return this.canvas.width;\n    }\n    set height(h) {\n      var _toInt2;\n      const height = (_toInt2 = toInt(h)) !== null && _toInt2 !== void 0 ? _toInt2 : this.canvas.height;\n      this.canvas.height = height;\n    }\n    get height() {\n      return this.canvas.height;\n    }\n    pointerMove(event) {\n      const stateMachines = Object.values(this.stateMachines).filter(sm => 'pointerMove' in sm);\n      if (!stateMachines.length) return;\n      const vector = this.getTransform(event);\n      if (!vector) return;\n      for (const stateMachine of stateMachines) {\n        stateMachine.pointerMove(vector.x, vector.y);\n      }\n    }\n    pointerDown(event) {\n      const stateMachines = Object.values(this.stateMachines).filter(sm => 'pointerDown' in sm);\n      if (!stateMachines.length) return;\n      const vector = this.getTransform(event);\n      if (!vector) return;\n      for (const stateMachine of stateMachines) {\n        stateMachine.pointerDown(vector.x, vector.y);\n      }\n    }\n    pointerUp(event) {\n      const stateMachines = Object.values(this.stateMachines).filter(sm => 'pointerUp' in sm);\n      if (!stateMachines.length) return;\n      const vector = this.getTransform(event);\n      if (!vector) return;\n      for (const stateMachine of stateMachines) {\n        stateMachine.pointerUp(vector.x, vector.y);\n      }\n    }\n    constructor(service, element) {\n      var _this3 = this;\n      this.service = service;\n      this.url = new BehaviorSubject(null);\n      this.arboardName = new BehaviorSubject(null);\n      this.boxes = {};\n      // Keep track of current state machine for event listeners\n      this.stateMachines = {};\n      this.viewbox = '0 0 100% 100%';\n      this.lazy = false;\n      this.fit = 'contain';\n      this.alignment = 'center';\n      this.artboardChange = new EventEmitter();\n      this.canvas = element.nativeElement;\n      this.whenVisible = onVisible(element.nativeElement);\n      this.loaded = this.url.pipe(filter(exist$3), distinctUntilChanged(), filter(() => typeof window !== 'undefined' && !!this.ctx),\n      // Make sure it's not ssr\n      switchMap(/*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (url) {\n          _this3.file = yield _this3.service.load(url);\n          _this3.rive = _this3.service.rive;\n          if (!_this3.rive) throw new Error('Service could not load rive');\n          // TODO: set offscreen renderer to true for webgl\n          _this3.renderer = _this3.rive.makeRenderer(_this3.canvas);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()), switchMap(_ => this.setArtboard()), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n    ngOnInit() {\n      this.onReady();\n    }\n    ngOnDestroy() {\n      // Timeout to avoid late request to a deleted artboard\n      setTimeout(() => {\n        var _this$renderer, _this$artboard, _this$file;\n        (_this$renderer = this.renderer) === null || _this$renderer === void 0 || _this$renderer.delete();\n        (_this$artboard = this.artboard) === null || _this$artboard === void 0 || _this$artboard.delete();\n        (_this$file = this.file) === null || _this$file === void 0 || _this$file.delete();\n      }, 100);\n    }\n    get ctx() {\n      if (!this._ctx) {\n        this._ctx = this.canvas.getContext('2d');\n      }\n      return this._ctx;\n    }\n    setArtboard() {\n      return this.arboardName.pipe(tap(() => {\n        var _this$artboard2;\n        return (_this$artboard2 = this.artboard) === null || _this$artboard2 === void 0 ? void 0 : _this$artboard2.delete();\n      }),\n      // Remove previous artboard if any\n      map(name => {\n        var _this$file2, _this$file3;\n        return name ? (_this$file2 = this.file) === null || _this$file2 === void 0 ? void 0 : _this$file2.artboardByName(name) : (_this$file3 = this.file) === null || _this$file3 === void 0 ? void 0 : _this$file3.defaultArtboard();\n      }), tap(artboard => this.artboard = artboard), tap(() => this.artboardChange.emit(this.artboard)), map(() => true));\n    }\n    /**\n     * Calculate the box of the canvas based on viewbox, width and height\n     * It memorizes the values to avoid recalculation for each frame\n     */\n    get box() {\n      const w = this.width;\n      const h = this.height;\n      const boxId = `${this.viewbox} ${w} ${h}`;\n      if (!this.boxes[boxId]) {\n        const bounds = this.viewbox.split(' ');\n        if (bounds.length !== 4) throw new Error('View box should look like \"0 0 100% 100%\"');\n        const [minX, minY, maxX, maxY] = bounds.map((v, i) => {\n          const size = i % 2 === 0 ? w : h;\n          const percentage = v.endsWith('%') ? parseInt(v.slice(0, -1), 10) / 100 : parseInt(v, 10) / size;\n          return i < 2 ? -size * percentage : size / percentage;\n        });\n        this.boxes[boxId] = {\n          minX,\n          minY,\n          maxX,\n          maxY\n        };\n      }\n      return this.boxes[boxId];\n    }\n    get isLazy() {\n      return this.lazy === true || this.lazy === '';\n    }\n    get count() {\n      var _this$artboard3;\n      return (_this$artboard3 = this.artboard) === null || _this$artboard3 === void 0 ? void 0 : _this$artboard3.animationCount();\n    }\n    onReady() {\n      if (this.isLazy) {\n        return from(this.whenVisible).pipe(filter(isVisible => isVisible), switchMap(() => this.loaded));\n      }\n      return this.loaded;\n    }\n    draw(instance, delta, mix) {\n      if (!this.rive) throw new Error('Could not load rive before registrating instance');\n      if (!this.artboard) throw new Error('Could not load artboard before registrating instance');\n      if (!this.renderer) throw new Error('Could not load renderer before registrating instance');\n      this.renderer.clear();\n      // Move frame\n      if (isLinearAnimation(instance)) {\n        instance.advance(delta);\n        instance.apply(mix !== null && mix !== void 0 ? mix : 1);\n      } else {\n        instance.advance(delta);\n      }\n      this.artboard.advance(delta);\n      // Render frame on canvas\n      this.renderer.save();\n      // Align renderer if needed\n      const fit = this.rive.Fit[this.fit];\n      const alignment = this.rive.Alignment[this.alignment];\n      const box = this.box;\n      const bounds = this.artboard.bounds;\n      this.renderer.align(fit, alignment, box, bounds);\n      this.artboard.draw(this.renderer);\n      this.renderer.restore();\n      // TODO: If context is WebGL Flush\n      // this.renderer.flush();\n    }\n    getTransform(event) {\n      if (!this.rive) return;\n      if (!this.artboard) return;\n      const boundingRect = this.canvas.getBoundingClientRect();\n      const {\n        clientX,\n        clientY\n      } = getClientCoordinates(event);\n      if (!clientX && !clientY) return;\n      const canvasX = clientX - boundingRect.left;\n      const canvasY = clientY - boundingRect.top;\n      const forwardMatrix = this.rive.computeAlignment(this.rive.Fit[this.fit], this.rive.Alignment[this.alignment], {\n        minX: 0,\n        minY: 0,\n        maxX: boundingRect.width,\n        maxY: boundingRect.height\n      }, this.artboard.bounds);\n      const invertedMatrix = new this.rive.Mat2D();\n      forwardMatrix.invert(invertedMatrix);\n      const canvasCoordinatesVector = new this.rive.Vec2D(canvasX, canvasY);\n      const transformedVector = this.rive.mapXY(invertedMatrix, canvasCoordinatesVector);\n      const x = transformedVector.x();\n      const y = transformedVector.y();\n      transformedVector.delete();\n      invertedMatrix.delete();\n      canvasCoordinatesVector.delete();\n      forwardMatrix.delete();\n      return {\n        x,\n        y\n      };\n    }\n  }\n  _RiveCanvas = RiveCanvas;\n  _RiveCanvas.ɵfac = function _RiveCanvas_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveCanvas)(i0.ɵɵdirectiveInject(RiveService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  _RiveCanvas.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RiveCanvas,\n    selectors: [[\"canvas\", \"riv\", \"\"]],\n    hostBindings: function _RiveCanvas_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"touchmove\", function _RiveCanvas_touchmove_HostBindingHandler($event) {\n          return ctx.pointerMove($event);\n        })(\"mouseover\", function _RiveCanvas_mouseover_HostBindingHandler($event) {\n          return ctx.pointerMove($event);\n        })(\"mouseout\", function _RiveCanvas_mouseout_HostBindingHandler($event) {\n          return ctx.pointerMove($event);\n        })(\"mousemove\", function _RiveCanvas_mousemove_HostBindingHandler($event) {\n          return ctx.pointerMove($event);\n        })(\"touchstart\", function _RiveCanvas_touchstart_HostBindingHandler($event) {\n          return ctx.pointerDown($event);\n        })(\"mousedown\", function _RiveCanvas_mousedown_HostBindingHandler($event) {\n          return ctx.pointerDown($event);\n        })(\"touchend\", function _RiveCanvas_touchend_HostBindingHandler($event) {\n          return ctx.pointerUp($event);\n        })(\"mouseup\", function _RiveCanvas_mouseup_HostBindingHandler($event) {\n          return ctx.pointerUp($event);\n        });\n      }\n    },\n    inputs: {\n      riv: \"riv\",\n      name: [0, \"artboard\", \"name\"],\n      viewbox: \"viewbox\",\n      lazy: \"lazy\",\n      fit: \"fit\",\n      alignment: \"alignment\",\n      width: \"width\",\n      height: \"height\"\n    },\n    outputs: {\n      artboardChange: \"artboardChange\"\n    },\n    exportAs: [\"rivCanvas\"]\n  });\n  return RiveCanvas;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction isLinearAnimation(instance) {\n  return 'didLoop' in instance;\n}\nfunction getRivePlayerState(state = {}) {\n  return {\n    speed: 1,\n    playing: false,\n    mix: 1,\n    autoreset: false,\n    ...state\n  };\n}\nfunction frameToSec(frame, fps) {\n  return frame / fps;\n}\nfunction round(value) {\n  return Math.round((value + Number.EPSILON) * 10000) / 10000;\n}\nfunction exist$2(v) {\n  return v !== undefined && v !== null;\n}\nfunction getStart(animation) {\n  if (!animation.workStart || animation.workStart === -1) return 0;\n  return round(animation.workStart / animation.fps);\n}\nfunction getEnd(animation) {\n  const end = !animation.workEnd || animation.workEnd === -1 ? animation.duration : animation.workEnd;\n  return round(end / animation.fps);\n}\nlet RivePlayer = /*#__PURE__*/(() => {\n  var _RivePlayer;\n  class RivePlayer {\n    /**\n     * Name of the rive animation in the current Artboard\n     * Either use name or index to select an animation\n     */\n    set name(name) {\n      if (typeof name !== 'string') return;\n      this.zone.runOutsideAngular(() => {\n        this.register(name);\n      });\n    }\n    /**\n     * Index of the rive animation in the current Artboard\n     * Either use index of name to select an animation\n     */\n    set index(value) {\n      const index = typeof value === 'string' ? parseInt(value) : value;\n      if (typeof index !== 'number') return;\n      this.zone.runOutsideAngular(() => {\n        this.register(index);\n      });\n    }\n    /** The mix of this animation in the current arboard */\n    set mix(value) {\n      const mix = typeof value === 'string' ? parseFloat(value) : value;\n      if (mix && mix >= 0 && mix <= 1) this.update({\n        mix\n      });\n    }\n    get mix() {\n      return this.state.getValue().mix;\n    }\n    /** Multiplicator of the speed for the animation */\n    set speed(value) {\n      const speed = typeof value === 'string' ? parseFloat(value) : value;\n      if (typeof speed === 'number') this.update({\n        speed\n      });\n    }\n    get speed() {\n      return this.state.getValue().speed;\n    }\n    set play(playing) {\n      if (playing === true || playing === '') {\n        this.update({\n          playing: true\n        });\n      } else if (playing === false) {\n        this.update({\n          playing: false\n        });\n      }\n    }\n    get play() {\n      return this.state.getValue().playing;\n    }\n    set time(value) {\n      const time = typeof value === 'string' ? parseFloat(value) : value;\n      if (typeof time === 'number') this.distance.next(time);\n    }\n    /**\n     * @deprecated This will be removed\n     * Consider using StateMachine instead\n     */\n    set autoreset(autoreset) {\n      if (autoreset === true || autoreset === '') {\n        this.update({\n          autoreset: true\n        });\n      } else if (autoreset === false) {\n        this.update({\n          autoreset: false\n        });\n      }\n    }\n    get autoreset() {\n      return this.state.getValue().autoreset;\n    }\n    /**\n     * @deprecated This will be removed\n     * Consider using StateMachine instead\n     */\n    set mode(mode) {\n      if (mode) this.update({\n        mode\n      });\n    }\n    get mode() {\n      return this.state.getValue().mode;\n    }\n    constructor(zone, canvas, service) {\n      this.zone = zone;\n      this.canvas = canvas;\n      this.service = service;\n      this.distance = new BehaviorSubject(null);\n      this.state = new BehaviorSubject(getRivePlayerState());\n      // eslint-disable-next-line @angular-eslint/no-output-native\n      this.load = new EventEmitter();\n      this.timeChange = new EventEmitter();\n      this.playChange = new EventEmitter();\n      this.speedChange = new EventEmitter();\n    }\n    ngOnDestroy() {\n      var _this$sub;\n      (_this$sub = this.sub) === null || _this$sub === void 0 || _this$sub.unsubscribe();\n      setTimeout(() => {\n        var _this$instance;\n        return (_this$instance = this.instance) === null || _this$instance === void 0 ? void 0 : _this$instance.delete();\n      }, 100);\n    }\n    update(state) {\n      const next = getRivePlayerState({\n        ...this.state.getValue(),\n        ...state\n      });\n      this.state.next(next);\n    }\n    initAnimation(name) {\n      if (!this.service.rive) throw new Error('Could not load animation instance before rive');\n      if (!this.canvas.artboard) throw new Error('Could not load animation instance before artboard');\n      const ref = typeof name === 'string' ? this.canvas.artboard.animationByName(name) : this.canvas.artboard.animationByIndex(name);\n      this.animation = ref;\n      this.instance = new this.service.rive.LinearAnimationInstance(ref, this.canvas.artboard);\n      this.startTime = getStart(this.instance);\n      this.endTime = getEnd(this.instance);\n      this.load.emit(this.instance);\n    }\n    getFrame(state) {\n      if (state.playing && this.service.frame) {\n        return this.service.frame.pipe(map(time => [state, time]));\n      } else {\n        return of(null);\n      }\n    }\n    register(name) {\n      var _this$sub2, _this$instance2;\n      (_this$sub2 = this.sub) === null || _this$sub2 === void 0 || _this$sub2.unsubscribe(); // Stop subscribing to previous animation if any\n      (_this$instance2 = this.instance) === null || _this$instance2 === void 0 || _this$instance2.delete(); // Remove old instance if any\n      // Update if time have changed from the input\n      const onTimeChange = this.distance.pipe(filter(exist$2), distinctUntilChanged(), map(time => time - this.instance.time));\n      // Update on frame change if playing\n      const onFrameChange = this.state.pipe(switchMap(state => this.getFrame(state)), filter(exist$2), map(([state, time]) => this.moveFrame(state, time)), tap(delta => {\n        this.zone.run(() => this.timeChange.emit(this.instance.time + delta));\n      }));\n      // Wait for canvas & animation to be loaded\n      this.sub = this.canvas.onReady().pipe(map(() => this.initAnimation(name)), switchMap(() => merge(onTimeChange, onFrameChange))).subscribe(delta => this.applyChange(delta));\n    }\n    moveFrame(state, time) {\n      var _this$startTime, _this$endTime;\n      if (!this.instance) throw new Error('Could not load animation instance before running it');\n      if (!this.animation) throw new Error('Could not load animation before running it');\n      const {\n        speed,\n        autoreset,\n        mode\n      } = state;\n      // Default mode, don't apply any logic\n      if (!mode) return time / 1000 * speed;\n      let delta = time / 1000 * speed;\n      // Round to avoid JS error on division\n      const start = (_this$startTime = this.startTime) !== null && _this$startTime !== void 0 ? _this$startTime : 0;\n      const end = (_this$endTime = this.endTime) !== null && _this$endTime !== void 0 ? _this$endTime : this.instance.duration / this.instance.fps;\n      const currentTime = round(this.instance.time);\n      // When player hit floor\n      if (currentTime + delta < start) {\n        if (mode === 'loop' && speed < 0 && end) {\n          delta = end - currentTime; // end - currentTime\n        } else if (mode === 'ping-pong') {\n          delta = -delta;\n          this.update({\n            speed: -speed\n          });\n          this.zone.run(() => this.speedChange.emit(-speed));\n        } else if (mode === 'one-shot') {\n          this.update({\n            playing: false\n          });\n          this.zone.run(() => this.playChange.emit(false));\n          delta = start - currentTime;\n        }\n      }\n      // Put before \"hit last frame\" else currentTime + delta > end\n      if (mode === 'one-shot' && autoreset) {\n        if (speed > 0 && currentTime === end) {\n          delta = start - end;\n        }\n        if (speed < 0 && currentTime === start) {\n          delta = end - start;\n        }\n      }\n      // When player hit last frame\n      if (currentTime + delta > end) {\n        if (mode === 'loop' && speed > 0) {\n          delta = start - currentTime;\n        } else if (mode === 'ping-pong') {\n          delta = -delta;\n          this.update({\n            speed: -speed\n          });\n          this.zone.run(() => this.speedChange.emit(-speed));\n        } else if (mode === 'one-shot') {\n          this.update({\n            playing: false\n          });\n          this.zone.run(() => this.playChange.emit(false));\n          delta = end - currentTime;\n        }\n      }\n      return delta;\n    }\n    applyChange(delta) {\n      var _this$service$rive;\n      // We need to use requestAnimationFrame when delta is changed by the time\n      (_this$service$rive = this.service.rive) === null || _this$service$rive === void 0 || _this$service$rive.requestAnimationFrame(() => {\n        if (!this.instance) throw new Error('Could not load animation instance before running it');\n        this.canvas.draw(this.instance, delta, this.state.getValue().mix);\n      });\n    }\n  }\n  _RivePlayer = RivePlayer;\n  _RivePlayer.ɵfac = function _RivePlayer_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RivePlayer)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(RiveCanvas), i0.ɵɵdirectiveInject(RiveService));\n  };\n  _RivePlayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RivePlayer,\n    selectors: [[\"riv-player\"], [\"\", \"rivPlayer\", \"\"]],\n    inputs: {\n      name: \"name\",\n      index: \"index\",\n      mix: \"mix\",\n      speed: \"speed\",\n      play: \"play\",\n      time: \"time\",\n      autoreset: \"autoreset\",\n      mode: \"mode\"\n    },\n    outputs: {\n      load: \"load\",\n      timeChange: \"timeChange\",\n      playChange: \"playChange\",\n      speedChange: \"speedChange\"\n    },\n    exportAs: [\"rivPlayer\"]\n  });\n  return RivePlayer;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getRiveAnimationState(state = {}) {\n  return {\n    speed: 1,\n    playing: false,\n    mix: 1,\n    ...state\n  };\n}\nfunction exist$1(v) {\n  return v !== undefined && v !== null;\n}\nfunction assertAnimation(animation, artboard, name) {\n  var _artboard$name;\n  if (animation) return;\n  const artboardName = (_artboard$name = artboard.name) !== null && _artboard$name !== void 0 ? _artboard$name : 'Default';\n  const count = artboard.animationCount();\n  if (typeof name === 'number') {\n    throw new Error(`Provided index \"${name}\" for the animation of artboard \"${artboardName}\" is not available. Animation count is: ${count}`);\n  } else {\n    const names = [];\n    for (let i = 0; i < count; i++) {\n      names.push(artboard.animationByIndex(i).name);\n    }\n    throw new Error(`Provided name \"${name}\" for the animation of artboard \"${artboardName}\" is not available. Availables names are: ${JSON.stringify(names)}`);\n  }\n}\nlet RiveLinearAnimation = /*#__PURE__*/(() => {\n  var _RiveLinearAnimation;\n  class RiveLinearAnimation {\n    /**\n     * Name of the rive animation in the current Artboard\n     * Either use name or index to select an animation\n     */\n    set name(name) {\n      if (typeof name !== 'string') return;\n      this.zone.runOutsideAngular(() => {\n        this.register(name);\n      });\n    }\n    /**\n     * Index of the rive animation in the current Artboard\n     * Either use index of name to select an animation\n     */\n    set index(value) {\n      const index = typeof value === 'string' ? parseInt(value) : value;\n      if (typeof index !== 'number') return;\n      this.zone.runOutsideAngular(() => {\n        this.register(index);\n      });\n    }\n    /** The mix of this animation in the current arboard */\n    set mix(value) {\n      const mix = typeof value === 'string' ? parseFloat(value) : value;\n      if (mix && mix >= 0 && mix <= 1) this.update({\n        mix\n      });\n    }\n    get mix() {\n      return this.state.getValue().mix;\n    }\n    /** Multiplicator for the speed of the animation */\n    set speed(value) {\n      const speed = typeof value === 'string' ? parseFloat(value) : value;\n      if (typeof speed === 'number') this.update({\n        speed\n      });\n    }\n    get speed() {\n      return this.state.getValue().speed;\n    }\n    /** If true, this animation is playing */\n    set play(playing) {\n      if (playing === true || playing === '') {\n        this.update({\n          playing: true\n        });\n      } else if (playing === false) {\n        this.update({\n          playing: false\n        });\n      }\n    }\n    get play() {\n      return this.state.getValue().playing;\n    }\n    constructor(zone, canvas, service) {\n      this.zone = zone;\n      this.canvas = canvas;\n      this.service = service;\n      this.distance = new BehaviorSubject(null);\n      this.state = new BehaviorSubject(getRiveAnimationState());\n      /** Emit when the LinearAnimation has been instantiated */\n      this.load = new EventEmitter();\n    }\n    ngOnDestroy() {\n      var _this$sub3, _this$instance3;\n      (_this$sub3 = this.sub) === null || _this$sub3 === void 0 || _this$sub3.unsubscribe();\n      (_this$instance3 = this.instance) === null || _this$instance3 === void 0 || _this$instance3.delete();\n      setTimeout(() => {\n        var _this$instance4;\n        return (_this$instance4 = this.instance) === null || _this$instance4 === void 0 ? void 0 : _this$instance4.delete();\n      }, 100);\n    }\n    update(state) {\n      const next = getRiveAnimationState({\n        ...this.state.getValue(),\n        ...state\n      });\n      this.state.next(next);\n    }\n    getFrame(state) {\n      if (state.playing && this.service.frame) {\n        return this.service.frame.pipe(map(time => [state, time]));\n      } else {\n        return of(null);\n      }\n    }\n    initAnimation(name) {\n      if (!this.canvas.rive) throw new Error('Could not load animation instance before rive');\n      if (!this.canvas.artboard) throw new Error('Could not load animation instance before artboard');\n      const ref = typeof name === 'string' ? this.canvas.artboard.animationByName(name) : this.canvas.artboard.animationByIndex(name);\n      assertAnimation(ref, this.canvas.artboard, name);\n      this.instance = new this.canvas.rive.LinearAnimationInstance(ref, this.canvas.artboard);\n      this.load.emit(this.instance);\n    }\n    register(name) {\n      var _this$sub4;\n      // Stop subscribing to previous animation if any\n      (_this$sub4 = this.sub) === null || _this$sub4 === void 0 || _this$sub4.unsubscribe();\n      // Update on frame change if playing\n      const onFrameChange = this.state.pipe(switchMap(state => this.getFrame(state)), filter(exist$1), map(([state, time]) => time / 1000 * state.speed));\n      // Wait for canvas & animation to be loaded\n      this.sub = this.canvas.onReady().pipe(map(() => this.initAnimation(name)), switchMap(() => onFrameChange)).subscribe(delta => this.applyChange(delta));\n    }\n    applyChange(delta) {\n      if (!this.instance) throw new Error('Could not load animation instance before running it');\n      this.canvas.draw(this.instance, delta, this.state.getValue().mix);\n    }\n  }\n  _RiveLinearAnimation = RiveLinearAnimation;\n  _RiveLinearAnimation.ɵfac = function _RiveLinearAnimation_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveLinearAnimation)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(RiveCanvas), i0.ɵɵdirectiveInject(RiveService));\n  };\n  _RiveLinearAnimation.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RiveLinearAnimation,\n    selectors: [[\"riv-animation\"], [\"\", \"rivAnimation\", \"\"]],\n    inputs: {\n      name: \"name\",\n      index: \"index\",\n      mix: \"mix\",\n      speed: \"speed\",\n      play: \"play\"\n    },\n    outputs: {\n      load: \"load\"\n    },\n    exportAs: [\"rivAnimation\"]\n  });\n  return RiveLinearAnimation;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RiveTransformComponent = /*#__PURE__*/(() => {\n  var _RiveTransformComponent;\n  class RiveTransformComponent {\n    set name(name) {\n      if (typeof name !== 'string') return;\n      this.canvas.onReady().subscribe(() => {\n        this.component = this.getComponent(name);\n        if (!this.component) throw new Error(`Could not find component with name: \"${name}\"`);\n        for (const key in this.state) {\n          this.component[key] = this.state[key];\n        }\n      });\n    }\n    set scale(value) {\n      this.set('scaleX', value);\n      this.set('scaleY', value);\n    }\n    set scaleX(value) {\n      this.set('scaleX', value);\n    }\n    set scaleY(value) {\n      this.set('scaleX', value);\n    }\n    set rotation(value) {\n      const v = typeof value === 'string' ? parseFloat(value) : value;\n      if (v) {\n        const rotation = Math.abs(v) > 2 * Math.PI ? v * (Math.PI / 180) : v;\n        this.set('rotation', rotation);\n      }\n    }\n    constructor(zone, canvas) {\n      this.zone = zone;\n      this.canvas = canvas;\n      this.state = {};\n    }\n    set(key, value) {\n      this.zone.runOutsideAngular(() => {\n        const v = typeof value === 'string' ? parseFloat(value) : value;\n        if (typeof v === 'number') {\n          if (this.component) this.component[key] = v;else this.state[key] = v;\n        }\n      });\n    }\n  }\n  _RiveTransformComponent = RiveTransformComponent;\n  _RiveTransformComponent.ɵfac = function _RiveTransformComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveTransformComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(RiveCanvas));\n  };\n  _RiveTransformComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RiveTransformComponent,\n    inputs: {\n      name: \"name\",\n      scale: \"scale\",\n      scaleX: \"scaleX\",\n      scaleY: \"scaleY\",\n      rotation: \"rotation\"\n    },\n    standalone: false\n  });\n  return RiveTransformComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RiveNode = /*#__PURE__*/(() => {\n  var _RiveNode;\n  class RiveNode extends RiveTransformComponent {\n    set x(value) {\n      this.set('x', value);\n    }\n    get x() {\n      var _this$component;\n      return (_this$component = this.component) === null || _this$component === void 0 ? void 0 : _this$component.x;\n    }\n    set y(value) {\n      this.set('y', value);\n    }\n    get y() {\n      var _this$component2;\n      return (_this$component2 = this.component) === null || _this$component2 === void 0 ? void 0 : _this$component2.y;\n    }\n    constructor(zone, canvas) {\n      super(zone, canvas);\n    }\n    getComponent(name) {\n      var _this$canvas$artboard;\n      return (_this$canvas$artboard = this.canvas.artboard) === null || _this$canvas$artboard === void 0 ? void 0 : _this$canvas$artboard.node(name);\n    }\n  }\n  _RiveNode = RiveNode;\n  _RiveNode.ɵfac = function _RiveNode_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveNode)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(RiveCanvas));\n  };\n  _RiveNode.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RiveNode,\n    selectors: [[\"riv-node\"], [\"\", \"rivNode\", \"\"]],\n    inputs: {\n      x: \"x\",\n      y: \"y\"\n    },\n    exportAs: [\"rivNode\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return RiveNode;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RiveBone = /*#__PURE__*/(() => {\n  var _RiveBone;\n  class RiveBone extends RiveTransformComponent {\n    set length(value) {\n      this.set('length', value);\n    }\n    constructor(zone, canvas) {\n      super(zone, canvas);\n    }\n    getComponent(name) {\n      var _this$canvas$artboard2;\n      return (_this$canvas$artboard2 = this.canvas.artboard) === null || _this$canvas$artboard2 === void 0 ? void 0 : _this$canvas$artboard2.bone(name);\n    }\n  }\n  _RiveBone = RiveBone;\n  _RiveBone.ɵfac = function _RiveBone_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveBone)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(RiveCanvas));\n  };\n  _RiveBone.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RiveBone,\n    selectors: [[\"riv-bone\"], [\"\", \"rivBone\", \"\"]],\n    inputs: {\n      length: \"length\"\n    },\n    exportAs: [\"rivBone\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return RiveBone;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RiveRootBone = /*#__PURE__*/(() => {\n  var _RiveRootBone;\n  class RiveRootBone extends RiveTransformComponent {\n    set x(value) {\n      this.set('x', value);\n    }\n    set y(value) {\n      this.set('y', value);\n    }\n    set length(value) {\n      this.set('length', value);\n    }\n    constructor(zone, canvas) {\n      super(zone, canvas);\n    }\n    getComponent(name) {\n      var _this$canvas$artboard3;\n      return (_this$canvas$artboard3 = this.canvas.artboard) === null || _this$canvas$artboard3 === void 0 ? void 0 : _this$canvas$artboard3.rootBone(name);\n    }\n  }\n  _RiveRootBone = RiveRootBone;\n  _RiveRootBone.ɵfac = function _RiveRootBone_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveRootBone)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(RiveCanvas));\n  };\n  _RiveRootBone.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RiveRootBone,\n    selectors: [[\"riv-root-bone\"], [\"\", \"rivRootBone\", \"\"]],\n    inputs: {\n      x: \"x\",\n      y: \"y\",\n      length: \"length\"\n    },\n    exportAs: [\"rivRootBone\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return RiveRootBone;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getInput(input) {\n  if (input.type === 56 /* InputTypes.Number */) return input.asNumber();\n  if (input.type === 59 /* InputTypes.Boolean */) return input.asBool();\n  if (input.type === 58 /* InputTypes.Trigger */) return input.asTrigger();\n  return input;\n}\nfunction assertStateMachine(animation, artboard, name) {\n  var _artboard$name2;\n  if (animation) return;\n  const artboardName = (_artboard$name2 = artboard.name) !== null && _artboard$name2 !== void 0 ? _artboard$name2 : 'Default';\n  const count = artboard.stateMachineCount();\n  if (typeof name === 'number') {\n    throw new Error(`Provided index \"${name}\" for the animation of artboard \"${artboardName}\" is not available. Animation count is: ${count}`);\n  } else {\n    const names = [];\n    for (let i = 0; i < count; i++) {\n      names.push(artboard.stateMachineByIndex(i).name);\n    }\n    throw new Error(`Provided name \"${name}\" for the animation of artboard \"${artboardName}\" is not available. Availables names are: ${JSON.stringify(names)}`);\n  }\n}\nlet RiveSMInput = /*#__PURE__*/(() => {\n  var _RiveSMInput;\n  class RiveSMInput {\n    set name(name) {\n      if (!name) return;\n      this._name = name;\n      if (this.input) return;\n      this.init(this.stateMachine.inputs[name]);\n    }\n    get name() {\n      var _this$input$name, _this$input;\n      return (_this$input$name = (_this$input = this.input) === null || _this$input === void 0 ? void 0 : _this$input.name) !== null && _this$input$name !== void 0 ? _this$input$name : this._name;\n    }\n    set value(rawValue) {\n      if (typeof rawValue === 'undefined' || rawValue === null) return;\n      const value = typeof rawValue === 'string' ? parseFloat(rawValue) : rawValue;\n      if (this.input) {\n        this.input.value = value;\n        this.change.emit(this.input);\n      } else {\n        this._value = value;\n      }\n    }\n    get value() {\n      var _this$input$value, _this$input2;\n      return (_this$input$value = (_this$input2 = this.input) === null || _this$input2 === void 0 ? void 0 : _this$input2.value) !== null && _this$input$value !== void 0 ? _this$input$value : this._value;\n    }\n    constructor(stateMachine) {\n      this.stateMachine = stateMachine;\n      this.change = new EventEmitter();\n      this.load = new EventEmitter();\n    }\n    /** @internal: Used by the RiveStateMachine */\n    init(input) {\n      var _this$input3;\n      if (!input || input.name === ((_this$input3 = this.input) === null || _this$input3 === void 0 ? void 0 : _this$input3.name)) return;\n      this.input = getInput(input);\n      this.load.emit(input);\n      if (typeof this._value !== 'undefined') {\n        this.input.value = this._value;\n        this.change.emit(this.input);\n      }\n      if (this.shouldFire) {\n        this.shouldFire(input);\n        delete this.shouldFire;\n      }\n    }\n    fire() {\n      const fire = input => {\n        if (input.type === 58 /* InputTypes.Trigger */) {\n          input.fire();\n          this.change.emit(input);\n        }\n      };\n      this.input ? fire(this.input) : this.shouldFire = fire;\n    }\n  }\n  _RiveSMInput = RiveSMInput;\n  _RiveSMInput.ɵfac = function _RiveSMInput_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveSMInput)(i0.ɵɵdirectiveInject(forwardRef(() => RiveStateMachine)));\n  };\n  _RiveSMInput.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RiveSMInput,\n    selectors: [[\"riv-input\"], [\"\", \"rivInput\", \"\"]],\n    inputs: {\n      name: \"name\",\n      value: \"value\"\n    },\n    outputs: {\n      change: \"change\",\n      load: \"load\"\n    },\n    exportAs: [\"rivInput\"]\n  });\n  return RiveSMInput;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction exist(v) {\n  return v !== undefined && v !== null;\n}\nlet RiveStateMachine = /*#__PURE__*/(() => {\n  var _RiveStateMachine;\n  class RiveStateMachine {\n    set name(name) {\n      if (typeof name !== 'string') return;\n      this.zone.runOutsideAngular(() => {\n        this.register(name);\n      });\n    }\n    set index(value) {\n      const index = typeof value === 'string' ? parseInt(value) : value;\n      if (typeof index !== 'number') return;\n      this.zone.runOutsideAngular(() => {\n        this.register(index);\n      });\n    }\n    set speed(value) {\n      const speed = typeof value === 'string' ? parseFloat(value) : value;\n      if (typeof speed === 'number') this.update({\n        speed\n      });\n    }\n    get speed() {\n      return this.state.getValue().speed;\n    }\n    set play(playing) {\n      if (playing === true || playing === '') {\n        this.update({\n          playing: true\n        });\n      } else if (playing === false) {\n        this.update({\n          playing: false\n        });\n      }\n    }\n    get play() {\n      return this.state.getValue().playing;\n    }\n    constructor(zone, canvas, service) {\n      this.zone = zone;\n      this.canvas = canvas;\n      this.service = service;\n      this.state = new BehaviorSubject({\n        speed: 1,\n        playing: false\n      });\n      this.inputs = {};\n      this.load = new EventEmitter();\n      this.stateChange = new EventEmitter();\n    }\n    ngOnDestroy() {\n      var _this$instance5, _this$sub5;\n      const name = (_this$instance5 = this.instance) === null || _this$instance5 === void 0 ? void 0 : _this$instance5.name;\n      if (name) delete this.canvas.stateMachines[name];\n      (_this$sub5 = this.sub) === null || _this$sub5 === void 0 || _this$sub5.unsubscribe();\n      setTimeout(() => {\n        var _this$instance6;\n        return (_this$instance6 = this.instance) === null || _this$instance6 === void 0 ? void 0 : _this$instance6.delete();\n      }, 100);\n    }\n    update(state) {\n      this.state.next({\n        ...this.state.getValue(),\n        ...state\n      });\n    }\n    setInput(input) {\n      var _this$riveInputs;\n      this.inputs[input.name] = input;\n      const riveInput = (_this$riveInputs = this.riveInputs) === null || _this$riveInputs === void 0 ? void 0 : _this$riveInputs.find(item => item.name === input.name);\n      if (riveInput) {\n        riveInput.init(input);\n      }\n    }\n    getFrame(state) {\n      if (state.playing && this.service.frame) {\n        return this.service.frame.pipe(map(time => [state, time]));\n      } else {\n        return of(null);\n      }\n    }\n    initStateMachine(name) {\n      if (!this.canvas.rive) throw new Error('Could not load state machine instance before rive');\n      if (!this.canvas.artboard) throw new Error('Could not load state machine instance before artboard');\n      const ref = typeof name === 'string' ? this.canvas.artboard.stateMachineByName(name) : this.canvas.artboard.stateMachineByIndex(name);\n      assertStateMachine(ref, this.canvas.artboard, name);\n      // Fetch the inputs from the runtime if we don't have them\n      this.instance = new this.canvas.rive.StateMachineInstance(ref, this.canvas.artboard);\n      this.canvas.stateMachines[this.instance.name] = this.instance;\n      for (let i = 0; i < this.instance.inputCount(); i++) {\n        this.setInput(this.instance.input(i));\n      }\n      this.load.emit(this.instance);\n    }\n    register(name) {\n      var _this$sub6;\n      // Stop subscribing to previous animation if any\n      (_this$sub6 = this.sub) === null || _this$sub6 === void 0 || _this$sub6.unsubscribe();\n      // Update on frame change if playing\n      const onFrameChange = this.state.pipe(switchMap(state => this.getFrame(state)), filter(exist), map(([state, time]) => time / 1000 * state.speed));\n      // Wait for canvas & animation to be loaded\n      this.sub = this.canvas.onReady().pipe(map(() => this.initStateMachine(name)), switchMap(() => onFrameChange)).subscribe(delta => this.applyChange(delta));\n    }\n    applyChange(delta) {\n      if (!this.instance) throw new Error('Could not load state machin instance before running it');\n      this.canvas.draw(this.instance, delta);\n      // Check for any state machines that had a state change\n      const changeCount = this.instance.stateChangedCount();\n      if (changeCount) {\n        const states = [];\n        for (let i = 0; i < changeCount; i++) {\n          states.push(this.instance.stateChangedNameByIndex(i));\n        }\n        this.stateChange.emit(states);\n      }\n    }\n  }\n  _RiveStateMachine = RiveStateMachine;\n  _RiveStateMachine.ɵfac = function _RiveStateMachine_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveStateMachine)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(RiveCanvas), i0.ɵɵdirectiveInject(RiveService));\n  };\n  _RiveStateMachine.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RiveStateMachine,\n    selectors: [[\"riv-state-machine\"], [\"\", \"rivStateMachine\", \"\"]],\n    contentQueries: function _RiveStateMachine_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, RiveSMInput, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.riveInputs = _t);\n      }\n    },\n    inputs: {\n      name: \"name\",\n      index: \"index\",\n      speed: \"speed\",\n      play: \"play\"\n    },\n    outputs: {\n      load: \"load\",\n      stateChange: \"stateChange\"\n    },\n    exportAs: [\"rivStateMachine\"]\n  });\n  return RiveStateMachine;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RiveModule = /*#__PURE__*/(() => {\n  var _RiveModule;\n  class RiveModule {}\n  _RiveModule = RiveModule;\n  _RiveModule.ɵfac = function _RiveModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RiveModule)();\n  };\n  _RiveModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _RiveModule\n  });\n  _RiveModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [HttpClientModule]\n  });\n  return RiveModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RIVE_FOLDER, RIVE_VERSION, RIVE_WASM, RiveBone, RiveCanvas, RiveLinearAnimation, RiveModule, RiveNode, RivePlayer, RiveRootBone, RiveSMInput, RiveService, RiveStateMachine, RiveTransformComponent, enterZone, frameToSec, round };\n//# sourceMappingURL=ng-rive.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}