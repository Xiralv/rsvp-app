{"ast":null,"code":"import _defineProperty from \"/Users/vlarix/Documents/mobile-apps/rsvp-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Observable, queueScheduler, observable, from } from 'rxjs';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject } from '@angular/core';\nimport { NetworkStatus, ApolloClient, gql as gql$1 } from '@apollo/client/core';\nimport { map, startWith, observeOn } from 'rxjs/operators';\nfunction fromPromise(promiseFn) {\n  return new Observable(subscriber => {\n    promiseFn().then(result => {\n      if (!subscriber.closed) {\n        subscriber.next(result);\n        subscriber.complete();\n      }\n    }, error => {\n      if (!subscriber.closed) {\n        subscriber.error(error);\n      }\n    });\n    return () => subscriber.unsubscribe();\n  });\n}\nfunction useMutationLoading(source, enabled) {\n  if (!enabled) {\n    return source.pipe(map(result => ({\n      ...result,\n      loading: false\n    })));\n  }\n  return source.pipe(startWith({\n    loading: true\n  }), map(result => ({\n    ...result,\n    loading: !!result.loading\n  })));\n}\nclass ZoneScheduler {\n  constructor(zone) {\n    _defineProperty(this, \"zone\", void 0);\n    _defineProperty(this, \"now\", Date.now ? Date.now : () => +new Date());\n    this.zone = zone;\n  }\n  schedule(work, delay = 0, state) {\n    return this.zone.run(() => queueScheduler.schedule(work, delay, state));\n  }\n}\nfunction fixObservable(obs) {\n  obs[observable] = () => obs;\n  return obs;\n}\nfunction wrapWithZone(obs, ngZone) {\n  return obs.pipe(observeOn(new ZoneScheduler(ngZone)));\n}\nfunction useInitialLoading(obsQuery) {\n  return function useInitialLoadingOperator(source) {\n    return new Observable(function useInitialLoadingSubscription(subscriber) {\n      const currentResult = obsQuery.getCurrentResult();\n      const {\n        loading,\n        errors,\n        error,\n        partial,\n        data\n      } = currentResult;\n      const {\n        partialRefetch,\n        fetchPolicy\n      } = obsQuery.options;\n      const hasError = errors || error;\n      if (partialRefetch && partial && (!data || Object.keys(data).length === 0) && fetchPolicy !== 'cache-only' && !loading && !hasError) {\n        subscriber.next({\n          ...currentResult,\n          loading: true,\n          networkStatus: NetworkStatus.loading\n        });\n      }\n      return source.subscribe(subscriber);\n    });\n  };\n}\nclass QueryRef {\n  constructor(obsQuery, ngZone, options) {\n    _defineProperty(this, \"obsQuery\", void 0);\n    _defineProperty(this, \"valueChanges\", void 0);\n    _defineProperty(this, \"queryId\", void 0);\n    this.obsQuery = obsQuery;\n    const wrapped = wrapWithZone(from(fixObservable(this.obsQuery)), ngZone);\n    this.valueChanges = options.useInitialLoading ? wrapped.pipe(useInitialLoading(this.obsQuery)) : wrapped;\n    this.queryId = this.obsQuery.queryId;\n  }\n  // ObservableQuery's methods\n  get options() {\n    return this.obsQuery.options;\n  }\n  get variables() {\n    return this.obsQuery.variables;\n  }\n  result() {\n    return this.obsQuery.result();\n  }\n  getCurrentResult() {\n    return this.obsQuery.getCurrentResult();\n  }\n  getLastResult() {\n    return this.obsQuery.getLastResult();\n  }\n  getLastError() {\n    return this.obsQuery.getLastError();\n  }\n  resetLastResults() {\n    return this.obsQuery.resetLastResults();\n  }\n  refetch(variables) {\n    return this.obsQuery.refetch(variables);\n  }\n  fetchMore(fetchMoreOptions) {\n    return this.obsQuery.fetchMore(fetchMoreOptions);\n  }\n  subscribeToMore(options) {\n    return this.obsQuery.subscribeToMore(options);\n  }\n  updateQuery(mapFn) {\n    return this.obsQuery.updateQuery(mapFn);\n  }\n  stopPolling() {\n    return this.obsQuery.stopPolling();\n  }\n  startPolling(pollInterval) {\n    return this.obsQuery.startPolling(pollInterval);\n  }\n  setOptions(opts) {\n    return this.obsQuery.setOptions(opts);\n  }\n  setVariables(variables) {\n    return this.obsQuery.setVariables(variables);\n  }\n}\nconst APOLLO_FLAGS = new InjectionToken('APOLLO_FLAGS');\nconst APOLLO_OPTIONS = new InjectionToken('APOLLO_OPTIONS');\nconst APOLLO_NAMED_OPTIONS = new InjectionToken('APOLLO_NAMED_OPTIONS');\nclass ApolloBase {\n  constructor(ngZone, flags, _client) {\n    var _flags$useInitialLoad, _flags$useMutationLoa;\n    _defineProperty(this, \"ngZone\", void 0);\n    _defineProperty(this, \"flags\", void 0);\n    _defineProperty(this, \"_client\", void 0);\n    _defineProperty(this, \"useInitialLoading\", void 0);\n    _defineProperty(this, \"useMutationLoading\", void 0);\n    this.ngZone = ngZone;\n    this.flags = flags;\n    this._client = _client;\n    this.useInitialLoading = (_flags$useInitialLoad = flags === null || flags === void 0 ? void 0 : flags.useInitialLoading) !== null && _flags$useInitialLoad !== void 0 ? _flags$useInitialLoad : false;\n    this.useMutationLoading = (_flags$useMutationLoa = flags === null || flags === void 0 ? void 0 : flags.useMutationLoading) !== null && _flags$useMutationLoa !== void 0 ? _flags$useMutationLoa : false;\n  }\n  watchQuery(options) {\n    return new QueryRef(this.ensureClient().watchQuery({\n      ...options\n    }), this.ngZone, {\n      useInitialLoading: this.useInitialLoading,\n      ...options\n    });\n  }\n  query(options) {\n    return fromPromise(() => this.ensureClient().query({\n      ...options\n    }));\n  }\n  mutate(options) {\n    var _options$useMutationL;\n    return useMutationLoading(fromPromise(() => this.ensureClient().mutate({\n      ...options\n    })), (_options$useMutationL = options.useMutationLoading) !== null && _options$useMutationL !== void 0 ? _options$useMutationL : this.useMutationLoading);\n  }\n  watchFragment(options, extra) {\n    const obs = from(fixObservable(this.ensureClient().watchFragment({\n      ...options\n    })));\n    return extra && extra.useZone !== true ? obs : wrapWithZone(obs, this.ngZone);\n  }\n  subscribe(options, extra) {\n    const obs = from(fixObservable(this.ensureClient().subscribe({\n      ...options\n    })));\n    return extra && extra.useZone !== true ? obs : wrapWithZone(obs, this.ngZone);\n  }\n  /**\n   * Get an instance of ApolloClient\n   */\n  get client() {\n    return this.ensureClient();\n  }\n  /**\n   * Set a new instance of ApolloClient\n   * Remember to clean up the store before setting a new client.\n   *\n   * @param client ApolloClient instance\n   */\n  set client(client) {\n    if (this._client) {\n      throw new Error('Client has been already defined');\n    }\n    this._client = client;\n  }\n  ensureClient() {\n    this.checkInstance();\n    return this._client;\n  }\n  checkInstance() {\n    if (this._client) {\n      return true;\n    } else {\n      throw new Error('Client has not been defined yet');\n    }\n  }\n}\nlet Apollo = /*#__PURE__*/(() => {\n  var _Apollo;\n  class Apollo extends ApolloBase {\n    constructor(ngZone, apolloOptions, apolloNamedOptions, flags) {\n      super(ngZone, flags);\n      _defineProperty(this, \"map\", new Map());\n      if (apolloOptions) {\n        this.createDefault(apolloOptions);\n      }\n      if (apolloNamedOptions && typeof apolloNamedOptions === 'object') {\n        for (let name in apolloNamedOptions) {\n          if (apolloNamedOptions.hasOwnProperty(name)) {\n            const options = apolloNamedOptions[name];\n            this.create(options, name);\n          }\n        }\n      }\n    }\n    /**\n     * Create an instance of ApolloClient\n     * @param options Options required to create ApolloClient\n     * @param name client's name\n     */\n    create(options, name) {\n      if (isNamed(name)) {\n        this.createNamed(name, options);\n      } else {\n        this.createDefault(options);\n      }\n    }\n    /**\n     * Use a default ApolloClient\n     */\n    default() {\n      return this;\n    }\n    /**\n     * Use a named ApolloClient\n     * @param name client's name\n     */\n    use(name) {\n      if (isNamed(name)) {\n        return this.map.get(name);\n      } else {\n        return this.default();\n      }\n    }\n    /**\n     * Create a default ApolloClient, same as `apollo.create(options)`\n     * @param options ApolloClient's options\n     */\n    createDefault(options) {\n      if (this._client) {\n        throw new Error('Apollo has been already created.');\n      }\n      this.client = this.ngZone.runOutsideAngular(() => new ApolloClient(options));\n    }\n    /**\n     * Create a named ApolloClient, same as `apollo.create(options, name)`\n     * @param name client's name\n     * @param options ApolloClient's options\n     */\n    createNamed(name, options) {\n      if (this.map.has(name)) {\n        throw new Error(`Client ${name} has been already created`);\n      }\n      this.map.set(name, new ApolloBase(this.ngZone, this.flags, this.ngZone.runOutsideAngular(() => new ApolloClient(options))));\n    }\n    /**\n     * Remember to clean up the store before removing a client\n     * @param name client's name\n     */\n    removeClient(name) {\n      if (isNamed(name)) {\n        this.map.delete(name);\n      } else {\n        this._client = undefined;\n      }\n    }\n  }\n  _Apollo = Apollo;\n  _defineProperty(Apollo, \"\\u0275fac\", function _Apollo_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Apollo)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(APOLLO_OPTIONS, 8), i0.ɵɵinject(APOLLO_NAMED_OPTIONS, 8), i0.ɵɵinject(APOLLO_FLAGS, 8));\n  });\n  _defineProperty(Apollo, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _Apollo,\n    factory: _Apollo.ɵfac\n  }));\n  return Apollo;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction isNamed(name) {\n  return !!name && name !== 'default';\n}\nfunction provideApollo(optionsFactory, flags = {}) {\n  return [Apollo, {\n    provide: APOLLO_OPTIONS,\n    useFactory: optionsFactory\n  }, {\n    provide: APOLLO_FLAGS,\n    useValue: flags\n  }];\n}\nfunction provideNamedApollo(optionsFactory, flags = {}) {\n  return [Apollo, {\n    provide: APOLLO_NAMED_OPTIONS,\n    useFactory: optionsFactory\n  }, {\n    provide: APOLLO_FLAGS,\n    useValue: flags\n  }];\n}\nlet Query = /*#__PURE__*/(() => {\n  var _Query;\n  class Query {\n    constructor(apollo) {\n      _defineProperty(this, \"apollo\", void 0);\n      _defineProperty(this, \"client\", 'default');\n      this.apollo = apollo;\n    }\n    watch(variables, options) {\n      return this.apollo.use(this.client).watchQuery({\n        ...options,\n        variables,\n        query: this.document\n      });\n    }\n    fetch(variables, options) {\n      return this.apollo.use(this.client).query({\n        ...options,\n        variables,\n        query: this.document\n      });\n    }\n  }\n  _Query = Query;\n  _defineProperty(Query, \"\\u0275fac\", function _Query_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Query)(i0.ɵɵinject(Apollo));\n  });\n  _defineProperty(Query, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _Query,\n    factory: _Query.ɵfac\n  }));\n  return Query;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet Mutation = /*#__PURE__*/(() => {\n  var _Mutation;\n  class Mutation {\n    constructor(apollo) {\n      _defineProperty(this, \"apollo\", void 0);\n      _defineProperty(this, \"client\", 'default');\n      this.apollo = apollo;\n    }\n    mutate(variables, options) {\n      return this.apollo.use(this.client).mutate({\n        ...options,\n        variables,\n        mutation: this.document\n      });\n    }\n  }\n  _Mutation = Mutation;\n  _defineProperty(Mutation, \"\\u0275fac\", function _Mutation_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Mutation)(i0.ɵɵinject(Apollo));\n  });\n  _defineProperty(Mutation, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _Mutation,\n    factory: _Mutation.ɵfac\n  }));\n  return Mutation;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet Subscription = /*#__PURE__*/(() => {\n  var _Subscription;\n  class Subscription {\n    constructor(apollo) {\n      _defineProperty(this, \"apollo\", void 0);\n      _defineProperty(this, \"client\", 'default');\n      this.apollo = apollo;\n    }\n    subscribe(variables, options, extra) {\n      return this.apollo.use(this.client).subscribe({\n        ...options,\n        variables,\n        query: this.document\n      }, extra);\n    }\n  }\n  _Subscription = Subscription;\n  _defineProperty(Subscription, \"\\u0275fac\", function _Subscription_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Subscription)(i0.ɵɵinject(Apollo));\n  });\n  _defineProperty(Subscription, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _Subscription,\n    factory: _Subscription.ɵfac\n  }));\n  return Subscription;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst typedGQLTag = gql$1;\nconst gql = typedGQLTag;\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { APOLLO_FLAGS, APOLLO_NAMED_OPTIONS, APOLLO_OPTIONS, Apollo, ApolloBase, Mutation, Query, QueryRef, Subscription, gql, provideApollo, provideNamedApollo };\n//# sourceMappingURL=ngApollo.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}