import { ElementRef, EventEmitter, NgZone, OnDestroy, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { RiveService } from './service';
import { Artboard, CanvasRenderer, RiveCanvas as Rive, File as RiveFile, AABB, StateMachineInstance, LinearAnimationInstance } from '@rive-app/canvas-advanced';
import * as i0 from "@angular/core";
export type CanvasFit = 'cover' | 'contain' | 'fill' | 'fitWidth' | 'fitHeight' | 'none' | 'scaleDown';
export type CanvasAlignment = 'center' | 'topLeft' | 'topCenter' | 'topRight' | 'centerLeft' | 'centerRight' | 'bottomLeft' | 'bottomCenter' | 'bottomRight';
export type RiveOrigin = string | File | Blob | null;
export declare function enterZone(zone: NgZone): <T>(source: Observable<T>) => Observable<T>;
export declare class RiveCanvas implements OnInit, OnDestroy {
    private service;
    private url;
    private arboardName;
    private _ctx?;
    private loaded;
    private boxes;
    canvas: HTMLCanvasElement;
    rive?: Rive;
    file?: RiveFile;
    artboard?: Artboard;
    renderer?: CanvasRenderer;
    stateMachines: Record<string, StateMachineInstance>;
    whenVisible: Promise<boolean>;
    set riv(url: RiveOrigin);
    set name(name: string);
    viewbox: string;
    lazy: boolean | '';
    fit: CanvasFit;
    alignment: CanvasAlignment;
    set width(w: number | string);
    get width(): number | string;
    set height(h: number | string);
    get height(): number | string;
    artboardChange: EventEmitter<Artboard>;
    private pointerMove;
    private pointerDown;
    private pointerUp;
    constructor(service: RiveService, element: ElementRef<HTMLCanvasElement>);
    ngOnInit(): void;
    ngOnDestroy(): void;
    get ctx(): CanvasRenderingContext2D;
    private setArtboard;
    /**
     * Calculate the box of the canvas based on viewbox, width and height
     * It memorizes the values to avoid recalculation for each frame
     */
    get box(): AABB;
    get isLazy(): boolean;
    get count(): number | undefined;
    onReady(): Observable<boolean>;
    draw(instance: LinearAnimationInstance, delta: number, mix: number): void;
    draw(instance: StateMachineInstance, delta: number): void;
    private getTransform;
    static ɵfac: i0.ɵɵFactoryDeclaration<RiveCanvas, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<RiveCanvas, "canvas[riv]", ["rivCanvas"], { "riv": { "alias": "riv"; "required": false; }; "name": { "alias": "artboard"; "required": false; }; "viewbox": { "alias": "viewbox"; "required": false; }; "lazy": { "alias": "lazy"; "required": false; }; "fit": { "alias": "fit"; "required": false; }; "alignment": { "alias": "alignment"; "required": false; }; "width": { "alias": "width"; "required": false; }; "height": { "alias": "height"; "required": false; }; }, { "artboardChange": "artboardChange"; }, never, never, true, never>;
}
