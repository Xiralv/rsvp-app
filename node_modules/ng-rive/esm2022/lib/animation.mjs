import { Directive, EventEmitter, Input, NgZone, Output } from "@angular/core";
import { BehaviorSubject, of } from "rxjs";
import { filter, map, switchMap } from "rxjs/operators";
import { RiveCanvas } from './canvas';
import { RiveService } from "./service";
import * as i0 from "@angular/core";
import * as i1 from "./canvas";
import * as i2 from "./service";
function getRiveAnimationState(state = {}) {
    return {
        speed: 1,
        playing: false,
        mix: 1,
        ...state
    };
}
function exist(v) {
    return v !== undefined && v !== null;
}
function assertAnimation(animation, artboard, name) {
    if (animation)
        return;
    const artboardName = artboard.name ?? 'Default';
    const count = artboard.animationCount();
    if (typeof name === 'number') {
        throw new Error(`Provided index "${name}" for the animation of artboard "${artboardName}" is not available. Animation count is: ${count}`);
    }
    else {
        const names = [];
        for (let i = 0; i < count; i++) {
            names.push(artboard.animationByIndex(i).name);
        }
        throw new Error(`Provided name "${name}" for the animation of artboard "${artboardName}" is not available. Availables names are: ${JSON.stringify(names)}`);
    }
}
export class RiveLinearAnimation {
    /**
     * Name of the rive animation in the current Artboard
     * Either use name or index to select an animation
     */
    set name(name) {
        if (typeof name !== 'string')
            return;
        this.zone.runOutsideAngular(() => {
            this.register(name);
        });
    }
    /**
     * Index of the rive animation in the current Artboard
     * Either use index of name to select an animation
     */
    set index(value) {
        const index = typeof value === 'string' ? parseInt(value) : value;
        if (typeof index !== 'number')
            return;
        this.zone.runOutsideAngular(() => {
            this.register(index);
        });
    }
    /** The mix of this animation in the current arboard */
    set mix(value) {
        const mix = typeof value === 'string' ? parseFloat(value) : value;
        if (mix && mix >= 0 && mix <= 1)
            this.update({ mix });
    }
    get mix() {
        return this.state.getValue().mix;
    }
    /** Multiplicator for the speed of the animation */
    set speed(value) {
        const speed = typeof value === 'string' ? parseFloat(value) : value;
        if (typeof speed === 'number')
            this.update({ speed });
    }
    get speed() {
        return this.state.getValue().speed;
    }
    /** If true, this animation is playing */
    set play(playing) {
        if (playing === true || playing === '') {
            this.update({ playing: true });
        }
        else if (playing === false) {
            this.update({ playing: false });
        }
    }
    get play() {
        return this.state.getValue().playing;
    }
    constructor(zone, canvas, service) {
        this.zone = zone;
        this.canvas = canvas;
        this.service = service;
        this.distance = new BehaviorSubject(null);
        this.state = new BehaviorSubject(getRiveAnimationState());
        /** Emit when the LinearAnimation has been instantiated */
        this.load = new EventEmitter();
    }
    ngOnDestroy() {
        this.sub?.unsubscribe();
        this.instance?.delete();
        setTimeout(() => this.instance?.delete(), 100);
    }
    update(state) {
        const next = getRiveAnimationState({ ...this.state.getValue(), ...state });
        this.state.next(next);
    }
    getFrame(state) {
        if (state.playing && this.service.frame) {
            return this.service.frame.pipe(map((time) => [state, time]));
        }
        else {
            return of(null);
        }
    }
    initAnimation(name) {
        if (!this.canvas.rive)
            throw new Error('Could not load animation instance before rive');
        if (!this.canvas.artboard)
            throw new Error('Could not load animation instance before artboard');
        const ref = typeof name === 'string'
            ? this.canvas.artboard.animationByName(name)
            : this.canvas.artboard.animationByIndex(name);
        assertAnimation(ref, this.canvas.artboard, name);
        this.instance = new this.canvas.rive.LinearAnimationInstance(ref, this.canvas.artboard);
        this.load.emit(this.instance);
    }
    register(name) {
        // Stop subscribing to previous animation if any
        this.sub?.unsubscribe();
        // Update on frame change if playing
        const onFrameChange = this.state.pipe(switchMap((state) => this.getFrame(state)), filter(exist), map(([state, time]) => (time / 1000) * state.speed));
        // Wait for canvas & animation to be loaded
        this.sub = this.canvas.onReady().pipe(map(() => this.initAnimation(name)), switchMap(() => onFrameChange)).subscribe((delta) => this.applyChange(delta));
    }
    applyChange(delta) {
        if (!this.instance)
            throw new Error('Could not load animation instance before running it');
        this.canvas.draw(this.instance, delta, this.state.getValue().mix);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.4", ngImport: i0, type: RiveLinearAnimation, deps: [{ token: i0.NgZone }, { token: i1.RiveCanvas }, { token: i2.RiveService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.4", type: RiveLinearAnimation, isStandalone: true, selector: "riv-animation, [rivAnimation]", inputs: { name: "name", index: "index", mix: "mix", speed: "speed", play: "play" }, outputs: { load: "load" }, exportAs: ["rivAnimation"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.4", ngImport: i0, type: RiveLinearAnimation, decorators: [{
            type: Directive,
            args: [{
                    selector: 'riv-animation, [rivAnimation]',
                    exportAs: 'rivAnimation',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i1.RiveCanvas }, { type: i2.RiveService }]; }, propDecorators: { name: [{
                type: Input
            }], index: [{
                type: Input
            }], mix: [{
                type: Input
            }], speed: [{
                type: Input
            }], play: [{
                type: Input
            }], load: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5pbWF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy9uZy1yaXZlL3NyYy9saWIvYW5pbWF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQWEsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzFGLE9BQU8sRUFBRSxlQUFlLEVBQUUsRUFBRSxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxXQUFXLENBQUM7Ozs7QUFVeEMsU0FBUyxxQkFBcUIsQ0FBQyxRQUFxQyxFQUFFO0lBQ3BFLE9BQU87UUFDTCxLQUFLLEVBQUUsQ0FBQztRQUNSLE9BQU8sRUFBRSxLQUFLO1FBQ2QsR0FBRyxFQUFFLENBQUM7UUFDTixHQUFHLEtBQUs7S0FDVCxDQUFBO0FBQ0gsQ0FBQztBQUVELFNBQVMsS0FBSyxDQUFJLENBQXVCO0lBQ3ZDLE9BQU8sQ0FBQyxLQUFLLFNBQVMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDO0FBQ3ZDLENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxTQUEwQixFQUFFLFFBQWtCLEVBQUUsSUFBcUI7SUFDNUYsSUFBSSxTQUFTO1FBQUUsT0FBTztJQUN0QixNQUFNLFlBQVksR0FBRyxRQUFRLENBQUMsSUFBSSxJQUFJLFNBQVMsQ0FBQztJQUNoRCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDeEMsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7UUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsSUFBSSxvQ0FBb0MsWUFB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QkFBaEIsS0FBSztnQkFZSSxJQUFJO3NCQUFiLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE5nWm9uZSwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIG9mLCBTdWJzY3JpcHRpb24gfSBmcm9tIFwicnhqc1wiO1xyXG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgc3dpdGNoTWFwIH0gZnJvbSBcInJ4anMvb3BlcmF0b3JzXCI7XHJcbmltcG9ydCB7IFJpdmVDYW52YXMgfSBmcm9tICcuL2NhbnZhcyc7XHJcbmltcG9ydCB7IFJpdmVTZXJ2aWNlIH0gZnJvbSBcIi4vc2VydmljZVwiO1xyXG5pbXBvcnQgdHlwZSB7IEFydGJvYXJkLCBMaW5lYXJBbmltYXRpb25JbnN0YW5jZSwgTGluZWFyQW5pbWF0aW9uIH0gZnJvbSBcIkByaXZlLWFwcC9jYW52YXMtYWR2YW5jZWRcIjtcclxuXHJcbmludGVyZmFjZSBSaXZlQW5pbWF0aW9uU3RhdGUge1xyXG4gIHNwZWVkOiBudW1iZXI7XHJcbiAgcGxheWluZzogYm9vbGVhbjtcclxuICAvKiogV2VpZ2h0IG9mIHRoaXMgYW5pbWF0aW9uIG92ZXIgYW5vdGhlciAqL1xyXG4gIG1peDogbnVtYmVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRSaXZlQW5pbWF0aW9uU3RhdGUoc3RhdGU6IFBhcnRpYWw8Uml2ZUFuaW1hdGlvblN0YXRlPiA9IHt9KTogUml2ZUFuaW1hdGlvblN0YXRlIHtcclxuICByZXR1cm4ge1xyXG4gICAgc3BlZWQ6IDEsXHJcbiAgICBwbGF5aW5nOiBmYWxzZSxcclxuICAgIG1peDogMSxcclxuICAgIC4uLnN0YXRlXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBleGlzdDxUPih2OiBUIHwgdW5kZWZpbmVkIHwgbnVsbCk6IHYgaXMgVCB7XHJcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NlcnRBbmltYXRpb24oYW5pbWF0aW9uOiBMaW5lYXJBbmltYXRpb24sIGFydGJvYXJkOiBBcnRib2FyZCwgbmFtZTogc3RyaW5nIHwgbnVtYmVyKSB7XHJcbiAgaWYgKGFuaW1hdGlvbikgcmV0dXJuO1xyXG4gIGNvbnN0IGFydGJvYXJkTmFtZSA9IGFydGJvYXJkLm5hbWUgPz8gJ0RlZmF1bHQnO1xyXG4gIGNvbnN0IGNvdW50ID0gYXJ0Ym9hcmQuYW5pbWF0aW9uQ291bnQoKTtcclxuICBpZiAodHlwZW9mIG5hbWUgPT09ICdudW1iZXInKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVkIGluZGV4IFwiJHtuYW1lfVwiIGZvciB0aGUgYW5pbWF0aW9uIG9mIGFydGJvYXJkIFwiJHthcnRib2FyZE5hbWV9XCIgaXMgbm90IGF2YWlsYWJsZS4gQW5pbWF0aW9uIGNvdW50IGlzOiAke2NvdW50fWApXHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IG5hbWVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgIG5hbWVzLnB1c2goYXJ0Ym9hcmQuYW5pbWF0aW9uQnlJbmRleChpKS5uYW1lKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZWQgbmFtZSBcIiR7bmFtZX1cIiBmb3IgdGhlIGFuaW1hdGlvbiBvZiBhcnRib2FyZCBcIiR7YXJ0Ym9hcmROYW1lfVwiIGlzIG5vdCBhdmFpbGFibGUuIEF2YWlsYWJsZXMgbmFtZXMgYXJlOiAke0pTT04uc3RyaW5naWZ5KG5hbWVzKX1gKTtcclxuICB9XHJcbiAgXHJcbn1cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdyaXYtYW5pbWF0aW9uLCBbcml2QW5pbWF0aW9uXScsXHJcbiAgICBleHBvcnRBczogJ3JpdkFuaW1hdGlvbicsXHJcbiAgICBzdGFuZGFsb25lOiB0cnVlXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBSaXZlTGluZWFyQW5pbWF0aW9uIGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuICBwcml2YXRlIHN1Yj86IFN1YnNjcmlwdGlvbjtcclxuICBwcml2YXRlIGluc3RhbmNlPzogTGluZWFyQW5pbWF0aW9uSW5zdGFuY2U7XHJcbiAgZGlzdGFuY2UgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4gIHN0YXRlID0gbmV3IEJlaGF2aW9yU3ViamVjdDxSaXZlQW5pbWF0aW9uU3RhdGU+KGdldFJpdmVBbmltYXRpb25TdGF0ZSgpKTtcclxuXHJcbiAgLyoqXHJcbiAgICogTmFtZSBvZiB0aGUgcml2ZSBhbmltYXRpb24gaW4gdGhlIGN1cnJlbnQgQXJ0Ym9hcmRcclxuICAgKiBFaXRoZXIgdXNlIG5hbWUgb3IgaW5kZXggdG8gc2VsZWN0IGFuIGFuaW1hdGlvblxyXG4gICAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IG5hbWUobmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykgcmV0dXJuO1xyXG4gICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgdGhpcy5yZWdpc3RlcihuYW1lKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5kZXggb2YgdGhlIHJpdmUgYW5pbWF0aW9uIGluIHRoZSBjdXJyZW50IEFydGJvYXJkIFxyXG4gICAqIEVpdGhlciB1c2UgaW5kZXggb2YgbmFtZSB0byBzZWxlY3QgYW4gYW5pbWF0aW9uXHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICBzZXQgaW5kZXgodmFsdWU6IG51bWJlciB8IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybjtcclxuICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgIHRoaXMucmVnaXN0ZXIoaW5kZXgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogVGhlIG1peCBvZiB0aGlzIGFuaW1hdGlvbiBpbiB0aGUgY3VycmVudCBhcmJvYXJkICovXHJcbiAgQElucHV0KClcclxuICBzZXQgbWl4KHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsKSB7XHJcbiAgICBjb25zdCBtaXggPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTsgXHJcbiAgICBpZiAobWl4ICYmIG1peCA+PSAwICYmIG1peCA8PSAxKSB0aGlzLnVwZGF0ZSh7IG1peCB9KTtcclxuICB9XHJcbiAgZ2V0IG1peCgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlLmdldFZhbHVlKCkubWl4O1xyXG4gIH1cclxuXHJcbiAgLyoqIE11bHRpcGxpY2F0b3IgZm9yIHRoZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uICovXHJcbiAgQElucHV0KClcclxuICBzZXQgc3BlZWQodmFsdWU6IG51bWJlciB8IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwpIHtcclxuICAgIGNvbnN0IHNwZWVkID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XHJcbiAgICBpZiAodHlwZW9mIHNwZWVkID09PSAnbnVtYmVyJykgdGhpcy51cGRhdGUoeyBzcGVlZCB9KTtcclxuICB9XHJcbiAgZ2V0IHNwZWVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0VmFsdWUoKS5zcGVlZDtcclxuICB9XHJcblxyXG4gIC8qKiBJZiB0cnVlLCB0aGlzIGFuaW1hdGlvbiBpcyBwbGF5aW5nICovXHJcbiAgQElucHV0KCkgc2V0IHBsYXkocGxheWluZzogYm9vbGVhbiB8ICcnIHwgdW5kZWZpbmVkIHwgbnVsbCkge1xyXG4gICAgaWYgKHBsYXlpbmcgPT09IHRydWUgfHwgcGxheWluZyA9PT0gJycpIHtcclxuICAgICAgdGhpcy51cGRhdGUoeyBwbGF5aW5nOiB0cnVlIH0pO1xyXG4gICAgfSBlbHNlIGlmIChwbGF5aW5nID09PSBmYWxzZSkge1xyXG4gICAgICB0aGlzLnVwZGF0ZSh7IHBsYXlpbmc6IGZhbHNlIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXQgcGxheSgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlLmdldFZhbHVlKCkucGxheWluZztcclxuICB9XHJcbiAgXHJcbiAgLyoqIEVtaXQgd2hlbiB0aGUgTGluZWFyQW5pbWF0aW9uIGhhcyBiZWVuIGluc3RhbnRpYXRlZCAqL1xyXG4gIEBPdXRwdXQoKSBsb2FkID0gbmV3IEV2ZW50RW1pdHRlcjxMaW5lYXJBbmltYXRpb25JbnN0YW5jZT4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIHpvbmU6IE5nWm9uZSxcclxuICAgIHByaXZhdGUgY2FudmFzOiBSaXZlQ2FudmFzLFxyXG4gICAgcHJpdmF0ZSBzZXJ2aWNlOiBSaXZlU2VydmljZSxcclxuICApIHt9XHJcbiAgXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLnN1Yj8udW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuaW5zdGFuY2U/LmRlbGV0ZSgpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmluc3RhbmNlPy5kZWxldGUoKSwgMTAwKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlKHN0YXRlOiBQYXJ0aWFsPFJpdmVBbmltYXRpb25TdGF0ZT4pIHtcclxuICAgIGNvbnN0IG5leHQgPSBnZXRSaXZlQW5pbWF0aW9uU3RhdGUoey4uLnRoaXMuc3RhdGUuZ2V0VmFsdWUoKSwgLi4uc3RhdGUgfSlcclxuICAgIHRoaXMuc3RhdGUubmV4dChuZXh0KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0RnJhbWUoc3RhdGU6IFJpdmVBbmltYXRpb25TdGF0ZSkge1xyXG4gICAgaWYgKHN0YXRlLnBsYXlpbmcgJiYgdGhpcy5zZXJ2aWNlLmZyYW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlcnZpY2UuZnJhbWUucGlwZShtYXAoKHRpbWUpID0+IFtzdGF0ZSwgdGltZV0gYXMgY29uc3QpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBvZihudWxsKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbml0QW5pbWF0aW9uKG5hbWU6IHN0cmluZyB8IG51bWJlcikge1xyXG4gICAgaWYgKCF0aGlzLmNhbnZhcy5yaXZlKSB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGFuaW1hdGlvbiBpbnN0YW5jZSBiZWZvcmUgcml2ZScpO1xyXG4gICAgaWYgKCF0aGlzLmNhbnZhcy5hcnRib2FyZCkgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCBhbmltYXRpb24gaW5zdGFuY2UgYmVmb3JlIGFydGJvYXJkJyk7XHJcbiAgICBjb25zdCByZWYgPSB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZydcclxuICAgICAgPyB0aGlzLmNhbnZhcy5hcnRib2FyZC5hbmltYXRpb25CeU5hbWUobmFtZSlcclxuICAgICAgOiB0aGlzLmNhbnZhcy5hcnRib2FyZC5hbmltYXRpb25CeUluZGV4KG5hbWUpO1xyXG5cclxuICAgIGFzc2VydEFuaW1hdGlvbihyZWYsIHRoaXMuY2FudmFzLmFydGJvYXJkLCBuYW1lKTtcclxuXHJcbiAgICB0aGlzLmluc3RhbmNlID0gbmV3IHRoaXMuY2FudmFzLnJpdmUuTGluZWFyQW5pbWF0aW9uSW5zdGFuY2UocmVmLCB0aGlzLmNhbnZhcy5hcnRib2FyZCk7XHJcbiAgICB0aGlzLmxvYWQuZW1pdCh0aGlzLmluc3RhbmNlKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVnaXN0ZXIobmFtZTogc3RyaW5nIHwgbnVtYmVyKSB7XHJcbiAgICAvLyBTdG9wIHN1YnNjcmliaW5nIHRvIHByZXZpb3VzIGFuaW1hdGlvbiBpZiBhbnlcclxuICAgIHRoaXMuc3ViPy51bnN1YnNjcmliZSgpOyBcclxuXHJcbiAgICAvLyBVcGRhdGUgb24gZnJhbWUgY2hhbmdlIGlmIHBsYXlpbmdcclxuICAgIGNvbnN0IG9uRnJhbWVDaGFuZ2UgPSB0aGlzLnN0YXRlLnBpcGUoXHJcbiAgICAgIHN3aXRjaE1hcCgoc3RhdGUpID0+IHRoaXMuZ2V0RnJhbWUoc3RhdGUpKSxcclxuICAgICAgZmlsdGVyKGV4aXN0KSxcclxuICAgICAgbWFwKChbc3RhdGUsIHRpbWVdKSA9PiAodGltZSAvIDEwMDApICogc3RhdGUuc3BlZWQpLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBjYW52YXMgJiBhbmltYXRpb24gdG8gYmUgbG9hZGVkXHJcbiAgICB0aGlzLnN1YiA9IHRoaXMuY2FudmFzLm9uUmVhZHkoKS5waXBlKFxyXG4gICAgICBtYXAoKCkgPT4gdGhpcy5pbml0QW5pbWF0aW9uKG5hbWUpKSxcclxuICAgICAgc3dpdGNoTWFwKCgpID0+IG9uRnJhbWVDaGFuZ2UpXHJcbiAgICApLnN1YnNjcmliZSgoZGVsdGEpID0+IHRoaXMuYXBwbHlDaGFuZ2UoZGVsdGEpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXBwbHlDaGFuZ2UoZGVsdGE6IG51bWJlcikge1xyXG4gICAgaWYgKCF0aGlzLmluc3RhbmNlKSB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGFuaW1hdGlvbiBpbnN0YW5jZSBiZWZvcmUgcnVubmluZyBpdCcpO1xyXG4gICAgdGhpcy5jYW52YXMuZHJhdyh0aGlzLmluc3RhbmNlLCBkZWx0YSwgdGhpcy5zdGF0ZS5nZXRWYWx1ZSgpLm1peCk7XHJcbiAgfVxyXG5cclxufSJdfQ==